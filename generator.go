package gosql

import (
	"bytes"

	gol "github.com/frk/gosql/internal/golang"
	sql "github.com/frk/gosql/internal/sqlang"
)

const (
	filepreamble = ` DO NOT EDIT. This file was generated by "github.com/frk/gosql".`
	gosqlimport  = `github.com/frk/gosql`
)

var (
	idblank     = gol.Ident{"_"}
	idrecv      = gol.Ident{"q"}
	idconn      = gol.Ident{"c"}
	ididx       = gol.Ident{"i"}
	iderr       = gol.Ident{"err"}
	idnew       = gol.Ident{"new"}
	idnil       = gol.Ident{"nil"}
	idquery     = gol.Ident{"queryString"}
	idparams    = gol.Ident{"params"}
	idrow       = gol.Ident{"row"}
	idrows      = gol.Ident{"rows"}
	idexec      = gol.Ident{"Exec"}
	idiface     = gol.Ident{"interface{}"}
	iderror     = gol.Ident{"error"}
	sxconn      = gol.SelectorExpr{X: gol.Ident{"gosql"}, Sel: gol.Ident{"Conn"}}
	sxexec      = gol.SelectorExpr{X: gol.Ident{"c"}, Sel: gol.Ident{"Exec"}}
	sxquery     = gol.SelectorExpr{X: gol.Ident{"c"}, Sel: gol.Ident{"Query"}}
	sxqueryrow  = gol.SelectorExpr{X: gol.Ident{"c"}, Sel: gol.Ident{"QueryRow"}}
	sxrowscan   = gol.SelectorExpr{X: gol.Ident{"row"}, Sel: gol.Ident{"Scan"}}
	sxrowsscan  = gol.SelectorExpr{X: gol.Ident{"rows"}, Sel: gol.Ident{"Scan"}}
	sxrowsclose = gol.SelectorExpr{X: gol.Ident{"rows"}, Sel: gol.Ident{"Close"}}
	sxrowsnext  = gol.SelectorExpr{X: gol.Ident{"rows"}, Sel: gol.Ident{"Next"}}
	sxrowserr   = gol.SelectorExpr{X: gol.Ident{"rows"}, Sel: gol.Ident{"Err"}}
)

type specinfo struct {
	spec *typespec
	info *pginfo
}

func generate(pkgname string, infos []*specinfo) (*bytes.Buffer, error) {
	g := &generator{infos: infos}
	if err := g.run(pkgname); err != nil {
		return nil, err
	}
	return &g.buf, nil
}

type generator struct {
	infos   []*specinfo
	pkgname string
	buf     bytes.Buffer

	file gol.File

	// spec specific state, needs to be reset on each iteration
	nparam int // number of parameters
}

func (g *generator) run(pkgname string) error {
	g.file.PkgName = pkgname
	g.file.Preamble = gol.CommentList{{filepreamble}}
	g.file.Imports = gol.ImportDecl{{Path: gosqlimport}}

	for _, si := range g.infos {
		g.nparam = 0

		execdecl := g.execdecl(si)
		g.file.Decls = append(g.file.Decls, execdecl)
	}

	return gol.Write(g.file, &g.buf)
}

func (g *generator) execdecl(si *specinfo) (fn gol.FuncDecl) {
	fn.Name = idexec
	fn.Recv.Name = idrecv
	fn.Recv.Type = gol.StarExpr{X: gol.Ident{si.spec.name}}
	fn.Type.Params = gol.ParamList{{Names: []gol.Ident{idconn}, Type: sxconn}}
	fn.Type.Results = gol.ParamList{{Type: iderror}}

	fn.Body.Add(g.querybuild(si))
	fn.Body.Add(gol.NL{})
	fn.Body.Add(g.queryexec(si))
	fn.Body.Add(g.returnstmt(si))
	return fn
}

func (g *generator) querybuild(si *specinfo) (stmt gol.Stmt) {
	decl := gol.GenDecl{Token: gol.GENDECL_CONST}
	decl.Specs = []gol.Spec{gol.ValueSpec{
		Names:   []gol.Ident{idquery},
		Values:  []gol.Expr{gol.RawStringNode{g.sqldelete(si)}},
		Comment: gol.CommentList{{Text: " `"}},
	}}

	stmt = gol.DeclStmt{decl}
	return stmt
}

func (g *generator) queryexec(si *specinfo) (stmt gol.Stmt) {
	args := gol.ArgsList{List: []gol.Expr{idquery}}
	args.AddExprs(g.queryargs(si.spec.where)...)

	if si.spec.returning == nil && si.spec.result == nil {
		asn := gol.AssignStmt{Token: gol.ASSIGN_DEFINE}
		asn.Lhs = []gol.Expr{idblank, iderr}
		asn.Rhs = []gol.Expr{gol.CallExpr{Fun: sxexec, Args: args}}
		return asn
	}

	if !si.spec.rel.rec.isslice {
		asn := gol.AssignStmt{Token: gol.ASSIGN_DEFINE}
		asn.Lhs = []gol.Expr{idrow}
		asn.Rhs = []gol.Expr{gol.CallExpr{Fun: sxqueryrow, Args: args}}
		return gol.StmtList{asn, gol.NL{}}
	}

	asn := gol.AssignStmt{Token: gol.ASSIGN_DEFINE}
	asn.Lhs = []gol.Expr{idrows, iderr}
	asn.Rhs = []gol.Expr{gol.CallExpr{Fun: sxquery, Args: args}}

	iferr := gol.IfStmt{}
	iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BINARY_NEQ, Y: idnil}
	iferr.Body = gol.BlockStmt{List: []gol.Stmt{gol.ReturnStmt{iderr}}}

	defclose := gol.DeferStmt{}
	defclose.Call = gol.CallExpr{Fun: sxrowsclose}

	fornext := g.fornext(si)
	return gol.StmtList{asn, iferr, defclose, gol.NL{}, fornext}
}

func (g *generator) fornext(si *specinfo) (stmt gol.ForStmt) {
	stmt.Cond = gol.CallExpr{Fun: sxrowsnext}
	// initialize
	{
		if record := si.spec.rel.rec; record.ispointer {
			init := gol.AssignStmt{Token: gol.ASSIGN_DEFINE}
			init.Lhs = []gol.Expr{gol.Ident{"v"}}
			init.Rhs = []gol.Expr{gol.CallExpr{Fun: idnew, Args: gol.ArgsList{List: []gol.Expr{g.rectype(record)}}}}
			stmt.Body.List = append(stmt.Body.List, init)
		} else {
			vs := gol.ValueSpec{Names: []gol.Ident{{"v"}}, Type: g.rectype(record)}
			init := gol.GenDecl{Token: gol.GENDECL_VAR}
			init.Specs = append(init.Specs, vs)
			stmt.Body.List = append(stmt.Body.List, gol.DeclStmt{init})
		}
	}

	// scan & assign error
	{
		var args gol.ArgsList
		if len(si.info.returning) > 2 {
			args.OnePerLine = 1
		}

		// The pfieldhandled map is used to keep track of pointer fields
		// that have already been initialized and their types imported.
		var pfieldhandled = make(map[string]bool)

		for _, item := range si.info.returning {
			var fx gol.Expr = gol.Ident{"v"}

			var fieldkey string // key for the pfieldhandled map
			for _, fe := range item.field.path {
				fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{fe.name}}

				fieldkey += fe.name
				if fe.ispointer && !pfieldhandled[fieldkey] {
					if fe.isimported {
						g.addimport(fe.typepkgpath, fe.typepkgname, fe.typepkglocal)
					}

					// initialize nested pointer field
					init := gol.AssignStmt{Token: gol.ASSIGN}
					init.Lhs = []gol.Expr{fx}
					init.Rhs = []gol.Expr{gol.CallExpr{Fun: idnew, Args: gol.ArgsList{List: []gol.Expr{g.fieldelemtype(fe)}}}}
					stmt.Body.List = append(stmt.Body.List, init)

					pfieldhandled[fieldkey] = true
				}
			}

			fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{item.field.name}}
			args.List = append(args.List, gol.UnaryExpr{Op: gol.UNARY_AMP, X: fx})
		}

		asn := gol.AssignStmt{Token: gol.ASSIGN_DEFINE}
		asn.Lhs = []gol.Expr{iderr}
		asn.Rhs = []gol.Expr{gol.CallExpr{Fun: sxrowsscan, Args: args}}
		stmt.Body.List = append(stmt.Body.List, asn)
	}

	// check error & newline
	{
		iferr := gol.IfStmt{}
		iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BINARY_NEQ, Y: idnil}
		iferr.Body = gol.BlockStmt{List: []gol.Stmt{gol.ReturnStmt{iderr}}}
		stmt.Body.List = append(stmt.Body.List, iferr, gol.NL{})
	}

	// append
	{
		appnd := gol.CallExpr{Fun: gol.Ident{"append"}}
		appnd.Args = gol.ArgsList{List: []gol.Expr{
			gol.SelectorExpr{X: idrecv, Sel: gol.Ident{si.spec.rel.name}},
			gol.Ident{"v"},
		}}

		asn := gol.AssignStmt{Token: gol.ASSIGN}
		asn.Lhs = []gol.Expr{gol.SelectorExpr{X: idrecv, Sel: gol.Ident{si.spec.rel.name}}}
		asn.Rhs = []gol.Expr{appnd}
		stmt.Body.List = append(stmt.Body.List, asn)
	}
	return stmt
}

func (g *generator) queryargs(w *whereblock) (args []gol.Expr) {
	if w == nil {
		return args
	}

	for _, item := range w.items {
		switch node := item.node.(type) {
		case *wherefield:
			sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{w.name}}
			sx = gol.SelectorExpr{X: sx, Sel: gol.Ident{node.name}}
			args = append(args, sx)
		case *wherecolumn:
		case *wherebetween:
		case *whereblock:
		}

	}
	return args
}

func (g *generator) returnstmt(si *specinfo) (stmt gol.Stmt) {
	// return the err variable if nothing to scan
	if si.spec.kind != speckindSelect && si.spec.returning == nil && si.spec.result == nil {
		return &gol.ReturnStmt{iderr}
	}

	if si.spec.returning != nil {
		rel := si.spec.rel

		// does the record type need pre-allocation? and is it imported?
		if rel.rec.base.isimported && (rel.rec.isslice || rel.rec.ispointer) {
			g.addimport(rel.rec.base.pkgpath, rel.rec.base.pkgname, rel.rec.base.pkglocal)
		}

		if rel.rec.isslice || rel.rec.isarray {
			return &gol.ReturnStmt{gol.CallExpr{Fun: sxrowserr}}
		} else {
			var list gol.StmtList // result

			// if the gosql.Return directive was used, make sure that the rel
			// field is properly initialized to avoid "nil pointer" panics.
			if rel.rec.ispointer {
				// initialize rel field
				init := gol.AssignStmt{Token: gol.ASSIGN}
				init.Lhs = []gol.Expr{gol.SelectorExpr{X: idrecv, Sel: gol.Ident{rel.name}}}
				init.Rhs = []gol.Expr{gol.CallExpr{Fun: idnew, Args: gol.ArgsList{List: []gol.Expr{g.rectype(rel.rec)}}}}
				list = append(list, init)
			}

			var args gol.ArgsList
			if len(si.info.returning) > 2 {
				args.OnePerLine = 1
			}

			// The pfieldhandled map is used to keep track of pointer fields
			// that have already been initialized and their types imported.
			var pfieldhandled = make(map[string]bool)

			for _, item := range si.info.returning {
				fx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{rel.name}}

				var fieldkey string // key for the pfieldhandled map
				for _, fe := range item.field.path {
					fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{fe.name}}

					fieldkey += fe.name
					if fe.ispointer && !pfieldhandled[fieldkey] {
						if fe.isimported {
							g.addimport(fe.typepkgpath, fe.typepkgname, fe.typepkglocal)
						}

						// initialize nested pointer field
						init := gol.AssignStmt{Token: gol.ASSIGN}
						init.Lhs = []gol.Expr{fx}
						init.Rhs = []gol.Expr{gol.CallExpr{Fun: idnew, Args: gol.ArgsList{List: []gol.Expr{g.fieldelemtype(fe)}}}}
						list = append(list, init)

						pfieldhandled[fieldkey] = true
					}
				}

				fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{item.field.name}}
				args.List = append(args.List, gol.UnaryExpr{Op: gol.UNARY_AMP, X: fx})
			}

			list = append(list, &gol.ReturnStmt{gol.CallExpr{Fun: sxrowscan, Args: args}})
			return list
		}
	}

	// result field
	if si.spec.result != nil {
		rel := si.spec.result
		// does the record type need pre-allocation? and is it imported?
		if rel.rec.base.isimported && (rel.rec.isslice || rel.rec.ispointer) {
			g.addimport(rel.rec.base.pkgpath, rel.rec.base.pkgname, rel.rec.base.pkglocal)
		}

		if rel.rec.isslice || rel.rec.isarray {
			return &gol.ReturnStmt{gol.CallExpr{Fun: sxrowserr}}
		} else {
			var list gol.StmtList // result

			// if the gosql.Return directive was used, make sure that the rel
			// field is properly initialized to avoid "nil pointer" panics.
			if rel.rec.ispointer {
				// initialize rel field
				init := gol.AssignStmt{Token: gol.ASSIGN}
				init.Lhs = []gol.Expr{gol.SelectorExpr{X: idrecv, Sel: gol.Ident{rel.name}}}
				init.Rhs = []gol.Expr{gol.CallExpr{Fun: idnew, Args: gol.ArgsList{List: []gol.Expr{g.rectype(rel.rec)}}}}
				list = append(list, init)
			}

			var args gol.ArgsList
			if len(si.info.returning) > 2 {
				args.OnePerLine = 1
			}

			// The pfieldhandled map is used to keep track of pointer fields
			// that have already been initialized and their types imported.
			var pfieldhandled = make(map[string]bool)

			for _, item := range si.info.returning {
				fx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{rel.name}}

				var fieldkey string // key for the pfieldhandled map
				for _, fe := range item.field.path {
					fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{fe.name}}

					fieldkey += fe.name
					if fe.ispointer && !pfieldhandled[fieldkey] {
						if fe.isimported {
							g.addimport(fe.typepkgpath, fe.typepkgname, fe.typepkglocal)
						}

						// initialize nested pointer field
						init := gol.AssignStmt{Token: gol.ASSIGN}
						init.Lhs = []gol.Expr{fx}
						init.Rhs = []gol.Expr{gol.CallExpr{Fun: idnew, Args: gol.ArgsList{List: []gol.Expr{g.fieldelemtype(fe)}}}}
						list = append(list, init)

						pfieldhandled[fieldkey] = true
					}
				}

				fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{item.field.name}}
				args.List = append(args.List, gol.UnaryExpr{Op: gol.UNARY_AMP, X: fx})
			}

			list = append(list, &gol.ReturnStmt{gol.CallExpr{Fun: sxrowscan, Args: args}})
			return list
		}
	}
	return stmt
}

func (g *generator) rectype(rec recordtype) gol.Expr {
	id := gol.Ident{rec.base.name}
	if rec.base.isimported {
		return gol.SelectorExpr{X: gol.Ident{rec.base.pkgname}, Sel: id}
	}
	return id
}

func (g *generator) fieldelemtype(fe *fieldelem) gol.Expr {
	id := gol.Ident{fe.typename}
	if fe.isimported {
		return gol.SelectorExpr{X: gol.Ident{fe.typepkgname}, Sel: id}
	}
	return id
}

func (g *generator) addimport(path, name, local string) {
	// first check that that package path hasn't yet been added to the imports
	for _, spec := range g.file.Imports {
		if string(spec.Path) == path {
			return
		}
	}

	// if the local name is the same as the package name set it to empty
	if local == name {
		local = ""
	}

	spec := gol.ImportSpec{Path: gol.String(path), Name: gol.Ident{local}}
	g.file.Imports = append(g.file.Imports, spec)
}

func (g *generator) sqldelete(si *specinfo) (delstmt sql.DeleteStatement) {
	delstmt.Table = g.sqlrelid(si.spec.rel.relid)
	delstmt.Using = g.sqlusing(si.spec.join)
	delstmt.Where = g.sqlwhere(si.spec.where)
	delstmt.Returning = g.sqlreturning(si.info.returning)
	return delstmt
}

func (g *generator) sqlwhere(w *whereblock) (where sql.WhereClause) {
	if w == nil {
		return where
	}

	where.Conds = g.sqlsearchconds(w)
	return where
}

func (g *generator) sqlsearchconds(w *whereblock) (conds []sql.SearchCondition) {
	for _, item := range w.items {
		sqlbool := boolop2sqlnode[item.op]

		switch node := item.node.(type) {
		case *wherefield:
			x := sql.BoolExpr{Bool: sqlbool}
			x.Lhs = g.sqlcolid(node.colid)
			x.Cmp = cmpop2sqlnode[node.cmp]
			x.Rhs = g.sqlparam()
			conds = append(conds, x)

		case *wherecolumn:
			x := sql.BoolExpr{Bool: sqlbool}
			x.Lhs = g.sqlcolid(node.colid)
			x.Cmp = cmpop2sqlnode[node.cmp]
			if !node.colid2.isempty() {
				x.Rhs = g.sqlcolid(node.colid2)
			} else if len(node.lit) > 0 {
				x.Rhs = sql.Literal(node.lit)
			}
			conds = append(conds, x)
		case *wherebetween:
			// TODO
		case *whereblock:
			xl := sql.BoolExprList{Bool: sqlbool}
			xl.List = g.sqlsearchconds(node)
			conds = append(conds, xl)
		}

	}
	return conds
}

func (g *generator) sqlusing(jb *joinblock) (using sql.UsingClause) {
	if jb == nil {
		return using
	}

	using.List = []sql.TableExpr{g.sqlrelid(jb.rel)}
	for _, item := range jb.items {
		var join sql.TableJoin
		join.Type = jointype2sqlnode[item.typ]
		join.Rel = g.sqlrelid(item.rel)
		for _, cond := range item.conds {
			var on sql.JoinOnExpr
			on.Bool = boolop2sqlnode[cond.op]
			on.Lhs = g.sqlcolid(cond.col1)
			on.Cmp = cmpop2sqlnode[cond.cmp]
			on.Rhs = g.sqlcolid(cond.col2)
			join.On.List = append(join.On.List, on)
		}

		using.List = append(using.List, join)
	}
	return using
}

func (g *generator) sqlreturning(fcs []*fieldcolumn) (returning sql.ReturningClause) {
	if fcs == nil {
		return returning
	}

	for _, fc := range fcs {
		returning = append(returning, g.sqlcolid(fc.colid))
	}
	return returning
}

func (g *generator) sqlrelid(id relid) sql.Ident {
	return sql.Ident{
		Name:  sql.Name(id.name),
		Qual:  id.qual,
		Alias: id.alias,
	}
}

func (g *generator) sqlcolid(id colid) sql.ColumnIdent {
	return sql.ColumnIdent{
		Name: sql.Name(id.name),
		Qual: id.qual,
	}
}

func (g *generator) sqlparam() sql.PositionalParameter {
	g.nparam += 1
	return sql.PositionalParameter(g.nparam)
}

var boolop2sqlnode = map[boolop]sql.BoolOp{
	booland: sql.BoolAnd,
	boolor:  sql.BoolOr,
	boolnot: sql.BoolNot,
}

var cmpop2sqlnode = map[cmpop]sql.CmpOp{
	cmpeq:  sql.CmpEq,
	cmpne:  sql.CmpNe,
	cmpne2: sql.CmpNe2,
	cmplt:  sql.CmpLt,
	cmpgt:  sql.CmpGt,
	cmple:  sql.CmpLe,
	cmpge:  sql.CmpGe,
}

var jointype2sqlnode = map[jointype]sql.JoinType{
	joinleft:  sql.JoinLeft,
	joinright: sql.JoinRight,
	joinfull:  sql.JoinFull,
	joincross: sql.JoinCross,
}
