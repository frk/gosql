package gosql

import (
	"bytes"
	"log"
	"strconv"

	gol "github.com/frk/gosql/internal/golang"
	sql "github.com/frk/gosql/internal/sqlang"
)

const (
	filepreamble = ` DO NOT EDIT. This file was generated by "github.com/frk/gosql".`
	gosqlimport  = `github.com/frk/gosql`
)

var (
	idblank             = gol.Ident{"_"}
	idrecv              = gol.Ident{"q"}
	idconn              = gol.Ident{"c"}
	ididx               = gol.Ident{"i"}
	iderr               = gol.Ident{"err"}
	idnew               = gol.Ident{"new"}
	idnil               = gol.Ident{"nil"}
	idlen               = gol.Ident{"len"}
	idi64               = gol.Ident{"i64"}
	idres               = gol.Ident{"res"}
	idrow               = gol.Ident{"row"}
	idmake              = gol.Ident{"make"}
	idrows              = gol.Ident{"rows"}
	idexec              = gol.Ident{"Exec"}
	iderror             = gol.Ident{"error"}
	idparams            = gol.Ident{"params"}
	idafterscan         = gol.Ident{"AfterScan"}
	idquery             = gol.Ident{"queryString"}
	idiface             = gol.Ident{"interface{}"}
	idifaces            = gol.Ident{"[]interface{}"}
	idordinals          = gol.QualifiedIdent{"gosql", "OrdinalParameters"}
	sxconn              = gol.QualifiedIdent{"gosql", "Conn"}
	sxerrorinfo         = gol.QualifiedIdent{"gosql", "ErrorInfo"}
	sxexec              = gol.QualifiedIdent{"c", "Exec"}
	sxquery             = gol.QualifiedIdent{"c", "Query"}
	sxqueryrow          = gol.QualifiedIdent{"c", "QueryRow"}
	sxrowscan           = gol.QualifiedIdent{"row", "Scan"}
	sxrowsscan          = gol.QualifiedIdent{"rows", "Scan"}
	sxrowsclose         = gol.QualifiedIdent{"rows", "Close"}
	callrowserr         = gol.CallExpr{Fun: gol.QualifiedIdent{"rows", "Err"}}
	callrowsnext        = gol.CallExpr{Fun: gol.QualifiedIdent{"rows", "Next"}}
	callresrowsaffected = gol.CallExpr{Fun: gol.QualifiedIdent{"res", "RowsAffected"}}
	callinvaluelist     = gol.CallExpr{Fun: gol.QualifiedIdent{"gosql", "InValueList"}}
	callmakeparams      = gol.CallExpr{Fun: gol.Ident{"make"}, Args: gol.ArgsList{List: idifaces}}
)

type specinfo struct {
	spec *typespec
	info *pginfo
}

func generate(pkgname string, infos []*specinfo) (*bytes.Buffer, error) {
	g := &generator{infos: infos}
	if err := g.run(pkgname); err != nil {
		return nil, err
	}
	return &g.buf, nil
}

type generator struct {
	infos   []*specinfo
	pkgname string
	buf     bytes.Buffer

	file gol.File

	// file specific state
	imports gol.ImportDecl

	// spec specific state, needs to be reset on each iteration
	nparam int                // number of parameters
	asvar  bool               // if true, the query string should be declared as a var, not const.
	fclose bool               // if true, the sql query needs to be closed (with right parentheses) after the filter's been added.
	insx   []gol.SelectorExpr // slice fields for IN clauses

	queryargs     []gol.ExprNode    // list of arguments to be passed to the query (Exec|Query|QueryRow)
	scanargs      []gol.ExprNode    // list of arguments to be passed to the Scan method
	scaninits     gol.StmtList      // list of pointer initializations for scanning nested fields
	inputcolumns  sql.NameGroup     //
	outputcolumns sql.ValueExprList //
	inputparams   sql.ValueExprList //
}

func (g *generator) run(pkgname string) error {
	g.imports.Specs = []gol.ImportSpec{{Path: gosqlimport}}

	for _, si := range g.infos {
		g.nparam = 0
		g.asvar = false
		g.fclose = false
		g.insx = nil
		g.queryargs = nil
		g.scanargs = nil
		g.scaninits = nil
		g.inputcolumns = nil
		g.outputcolumns = nil
		g.inputparams = nil

		execdecl := g.buildexecdecl(si)
		g.file.Decls = append(g.file.Decls, execdecl)
	}

	g.file.PkgName = pkgname
	g.file.Preamble = gol.LineComment{filepreamble}
	g.file.Imports = []gol.ImportDeclNode{g.imports}

	return gol.Write(g.file, &g.buf)
}

func (g *generator) buildexecdecl(si *specinfo) (m gol.MethodDecl) {
	m.Name = idexec
	m.Recv.Name = idrecv
	m.Recv.Type = gol.PointerRecvType{si.spec.name}
	m.Type.Params = gol.ParamList{{Names: idconn, Type: sxconn}}
	m.Type.Results = gol.ParamList{{Type: iderror}}

	g.buildinput(si)
	g.buildoutput(si)

	m.Body.Add(g.buildquerystring(si))
	m.Body.Add(gol.NL{})
	m.Body.Add(g.querydefaults(si))
	m.Body.Add(g.queryexec(si))
	m.Body.Add(g.returnstmt(si))
	return m
}

func (g *generator) buildinput(si *specinfo) {
	if si.spec.defaults != nil && si.spec.defaults.all {
		// use DEFAULTS ALL
	}

	rec := si.spec.rel.rec
	name := si.spec.rel.name

	// the root node for the fields to be stored
	root := gol.ExprNode(gol.SelectorExpr{X: idrecv, Sel: gol.Ident{name}})
	if rec.isslice {
		root = gol.Ident{"v"}
	}

	// pginfo.input is empty if this is a select, or a delete
	for _, item := range si.info.input {
		if item.field.readonly && !si.spec.shouldforce(item.colid) {
			continue
		}

		// go input
		fx := root
		for _, pe := range item.field.path {
			fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{pe.name}}
		}
		fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{item.field.name}}
		g.queryargs = append(g.queryargs, fx)

		// sql input
		g.inputcolumns = append(g.inputcolumns, sql.Name(item.column.name))
		g.inputparams = append(g.inputparams, g.sqlparam())
	}

	spec := si.spec
	if spec.where != nil && len(spec.where.items) > 0 {
		type loopstate struct {
			items []*predicateitem // the current iteration predicate items
			idx   int              // keeps track of the item index
			sx    gol.SelectorExpr // the selector expression for the current predicate field
		}

		sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{spec.where.name}}
		stack := []*loopstate{{items: spec.where.items, sx: sx}}

	stackloop:
		for len(stack) > 0 {
			loop := stack[len(stack)-1]
			for loop.idx < len(loop.items) {
				item := loop.items[loop.idx]
				loop.idx++

				switch node := item.node.(type) {
				case *nestedpredicate:
					loop2 := new(loopstate)
					loop2.items = node.items
					loop2.sx = gol.SelectorExpr{X: loop.sx, Sel: gol.Ident{node.name}}
					stack = append(stack, loop2)
					continue stackloop
				case *betweenpredicate:
					if x, ok := node.x.(*paramfield); ok {
						sx := gol.SelectorExpr{X: loop.sx, Sel: gol.Ident{node.name}}
						sx = gol.SelectorExpr{X: sx, Sel: gol.Ident{x.name}}
						g.queryargs = append(g.queryargs, sx)
					}
					if y, ok := node.y.(*paramfield); ok {
						sx := gol.SelectorExpr{X: loop.sx, Sel: gol.Ident{node.name}}
						sx = gol.SelectorExpr{X: sx, Sel: gol.Ident{y.name}}
						g.queryargs = append(g.queryargs, sx)
					}
				case *fieldpredicate:
					if node.pred != isin && node.pred != notin {
						var x gol.ExprNode

						x = gol.SelectorExpr{X: loop.sx, Sel: gol.Ident{node.field.name}}
						if node.qua > 0 {
							gotyp := node.field.typ.string(true)
							coltyp := node.coltype + "[]"
							sel, ok := gotyp2coltyp2converter[gotyp][coltyp]
							if !ok {
								// TODO should not happen here, this should be caught while scanning the db
								log.Fatalf("unsupported type conversion: %s - %s", gotyp, coltyp)
							}
							x = gol.CallExpr{Fun: sel, Args: gol.ArgsList{List: x}}
						}

						g.queryargs = append(g.queryargs, x)
					}
				case *columnpredicate:
					// nothing to do
				}
			}
			stack = stack[:len(stack)-1]
		}
	}

	if spec.limit != nil && len(spec.limit.field) > 0 {
		sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{spec.limit.field}}
		g.queryargs = append(g.queryargs, sx)
	}
	if spec.offset != nil && len(spec.offset.field) > 0 {
		sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{spec.offset.field}}
		g.queryargs = append(g.queryargs, sx)
	}
}

func (g *generator) buildoutput(si *specinfo) {
	if si.spec.kind != speckindSelect && si.spec.returning == nil && si.spec.result == nil {
		return // nothing to output
	}

	rec := si.spec.rel.rec
	name := si.spec.rel.name
	if si.spec.result != nil {
		rec = si.spec.result.rec
		name = si.spec.result.name
	}

	// the root node for the fields to be scanned
	root := gol.ExprNode(gol.SelectorExpr{X: idrecv, Sel: gol.Ident{name}})
	if rec.isslice || rec.isiter {
		root = gol.Ident{"v"}
	}

	// build the initialization statement for the root node
	var rootinit gol.StmtNode
	if !rec.isslice && !rec.isiter && rec.ispointer {
		g.scaninits = append(g.scaninits, gol.NL{})

		init := gol.AssignStmt{Token: gol.Assign}
		init.Lhs, init.Rhs = root, gol.CallNewExpr{g.rectype(rec)}
		rootinit = init
	} else if (rec.isslice || rec.isiter) && rec.ispointer {
		init := gol.AssignStmt{Token: gol.AssignDefine}
		init.Lhs, init.Rhs = root, gol.CallNewExpr{g.rectype(rec)}
		rootinit = init
	} else if (rec.isslice || rec.isiter) && !rec.ispointer {
		init := gol.VarDecl{}
		init.Spec = gol.ValueSpec{Names: gol.Ident{"v"}, Type: g.rectype(rec)}
		rootinit = gol.DeclStmt{init}
	}
	if rootinit != nil {
		g.scaninits = append(g.scaninits, rootinit)
	}

	// The initdone map is used to keep track of pointer fields whose
	// initialization statement has already been created and stored in the map.
	var initdone = make(map[string]bool)

	for _, item := range si.info.output {
		if item.field.writeonly && !si.spec.shouldforce(item.colid) {
			continue
		}

		fieldkey := "" // key for the initdone map

		fx := root
		for _, pe := range item.field.path {
			fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{pe.name}}

			fieldkey += pe.name
			if pe.ispointer && !initdone[fieldkey] {
				if pe.isimported {
					g.addimport(pe.typepkgpath, pe.typepkgname, pe.typepkglocal)
				}

				// nested pointer field initialization statement
				init := gol.AssignStmt{Token: gol.Assign}
				init.Lhs, init.Rhs = fx, gol.CallNewExpr{g.pathelemtype(pe)}
				g.scaninits = append(g.scaninits, init)

				initdone[fieldkey] = true
			}
		}

		fx = gol.SelectorExpr{X: fx, Sel: gol.Ident{item.field.name}}
		g.scanargs = append(g.scanargs, gol.UnaryExpr{Op: gol.UnaryAmp, X: fx})
		g.outputcolumns = append(g.outputcolumns, g.sqlcolexpr(item))
	}
}

func (g *generator) buildquerystring(si *specinfo) (stmt gol.StmtNode) {
	sqlnode := g.sqlnode(si)

	var decl gol.DeclNode
	if g.declarevar(si) {
		decl = gol.VarDecl{Spec: gol.ValueSpec{
			Names:   idquery,
			Values:  gol.RawStringNode{sqlnode},
			Comment: gol.LineComment{" `"},
		}}
	} else {
		decl = gol.ConstDecl{Spec: gol.ValueSpec{
			Names:   idquery,
			Values:  gol.RawStringNode{sqlnode},
			Comment: gol.LineComment{" `"},
		}}
	}

	if si.spec.kind == speckindInsert && si.spec.rel.rec.isslice {
		idrel := gol.QualifiedIdent{idrecv.Name, si.spec.rel.name}
		numfields := gol.IntLit(len(g.queryargs))

		// params := make([]interface{}, len(q.T)*numoffields)
		asn := gol.AssignStmt{Token: gol.AssignDefine}
		asn.Lhs = idparams
		asn.Rhs = gol.CallMakeExpr{
			Type: idifaces,
			Size: gol.BinaryExpr{
				Op: gol.BinaryMul,
				X:  gol.CallLenExpr{idrel},
				Y:  numfields,
			},
		}

		// for i, v := range q.Users {
		loop := gol.ForStmt{}
		{
			rangeclause := gol.ForRangeClause{}
			rangeclause.Key = gol.Ident{"i"}
			rangeclause.Value = gol.Ident{"v"}
			rangeclause.X = idrel
			rangeclause.Define = true
			loop.Clause = rangeclause

			// pos := i * 4
			asn2 := gol.AssignStmt{Token: gol.AssignDefine}
			asn2.Lhs = gol.Ident{"pos"}
			asn2.Rhs = gol.BinaryExpr{Op: gol.BinaryMul, X: gol.Ident{"i"}, Y: numfields}
			loop.Body = gol.BlockStmt{List: []gol.StmtNode{asn2, gol.NL{}}}

			assigns := make([]gol.StmtNode, len(g.queryargs))
			concats := make([]gol.ExprNode, len(g.queryargs)+1)

			for i, item := range g.queryargs {
				// pos+123
				idxexpr := gol.BinaryExpr{Op: gol.BinaryAdd, X: gol.Ident{"pos"}, Y: gol.IntLit(i)}

				// params[pos+123] = v.SomeField
				asn3 := gol.AssignStmt{Token: gol.Assign}
				asn3.Lhs = gol.IndexExpr{X: idparams, Index: idxexpr}
				asn3.Rhs = item
				assigns[i] = asn3

				// `, ` + gosql.OrdinalParameters[pos+2] +
				sep := `, `
				if i == 0 {
					sep = `(`
				}
				concat := gol.BinaryExpr{Op: gol.BinaryAdd}
				concat.X = gol.RawStringLit(sep)
				concat.Y = gol.IndexExpr{X: idordinals, Index: idxexpr}
				concats[i] = concat
			}
			concats[len(concats)-1] = gol.RawStringLit(`),`)

			asn4 := gol.AssignStmt{Token: gol.AssignAdd}
			asn4.Lhs = idquery
			asn4.Rhs = gol.MultiLineExpr{Op: gol.BinaryAdd, Exprs: concats}

			loop.Body.List = append(loop.Body.List, assigns...)
			loop.Body.List = append(loop.Body.List, gol.NL{}, asn4)
		}

		asn5 := gol.AssignStmt{Token: gol.Assign}
		asn5.Lhs = idquery
		asn5.Rhs = gol.SliceExpr{X: idquery,
			High: gol.BinaryExpr{Op: gol.BinarySub, X: gol.CallLenExpr{idquery}, Y: gol.IntLit(1)},
		}
		return gol.StmtList{gol.DeclStmt{decl}, gol.NL{}, asn, loop, gol.NL{}, asn5}

	} else if len(g.insx) > 0 {
		// prepare the var declarations
		vardecl := gol.VarDecl{}

		nstatic := gol.ValueSpec{}
		nstatic.Names = gol.Ident{"nstatic"}
		nstatic.Values = gol.IntLit(g.nparam)
		nstatic.Comment = gol.LineComment{" number of static parameters"}

		specs := gol.ValueSpecList{nstatic}
		for i, sx := range g.insx {
			num := strconv.Itoa(i + 1)

			lenspec := gol.ValueSpec{}
			lenspec.Names = gol.Ident{"len" + num}
			lenspec.Values = gol.CallExpr{Fun: idlen, Args: gol.ArgsList{List: sx}}
			lenspec.Comment = gol.LineComment{" length of slice #" + num + " to be unnested"}

			posspec := gol.ValueSpec{}
			posspec.Names = gol.Ident{"pos" + num}
			if i == 0 {
				// the first position is set to the value of nstatic
				posspec.Values = gol.Ident{"nstatic"}
			} else {
				// the rest of the positions are calculated from
				// adding the previous length to the previous position
				prev := strconv.Itoa(i)
				prevlen, prevpos := gol.Ident{"len" + prev}, gol.Ident{"pos" + prev}
				posspec.Values = gol.BinaryExpr{X: prevpos, Op: gol.BinaryAdd, Y: prevlen}
			}
			posspec.Comment = gol.LineComment{" starting position of slice #" + num + " parameters"}

			specs = append(specs, lenspec, posspec)
		}
		vardecl.Spec = specs

		// next is the query declaration
		list := gol.StmtList{gol.DeclStmt{vardecl}, gol.NL{}, gol.DeclStmt{decl}, gol.NL{}}

		// define the params variable
		asn := gol.AssignStmt{Token: gol.AssignDefine}
		asn.Lhs = idparams
		callmake := callmakeparams
		bin := gol.BinaryExpr{X: gol.Ident{"nstatic"}, Op: gol.BinaryAdd, Y: gol.Ident{"len1"}}
		for i := 1; i < len(g.insx); i++ {
			y := gol.Ident{"len" + strconv.Itoa(i+1)}
			bin = gol.BinaryExpr{X: bin, Op: gol.BinaryAdd, Y: y}
		}
		callmake.Args.AddExprs(bin)
		asn.Rhs = callmake
		list = append(list, asn)

		// directly assign non-slice params
		for i, arg := range g.queryargs {
			asn := gol.AssignStmt{Token: gol.Assign}
			asn.Lhs = gol.IndexExpr{X: idparams, Index: gol.IntLit(i)}
			asn.Rhs = arg
			list = append(list, asn)
		}

		for i, sx := range g.insx {
			lenid := gol.Ident{"len" + strconv.Itoa(i+1)}
			posid := gol.Ident{"pos" + strconv.Itoa(i+1)}

			forclause := gol.ForClause{}
			forclause.Init = gol.AssignStmt{Token: gol.AssignDefine, Lhs: ididx, Rhs: gol.IntLit(0)}
			forclause.Cond = gol.BinaryExpr{X: ididx, Op: gol.BinaryLss, Y: lenid}
			forclause.Post = gol.IncDecStmt{X: ididx, Token: gol.IncDecIncrement}
			loop := gol.ForStmt{Clause: forclause}

			asn := gol.AssignStmt{Token: gol.Assign}
			asn.Lhs = gol.IndexExpr{X: idparams, Index: gol.BinaryExpr{X: posid, Op: gol.BinaryAdd, Y: ididx}}
			asn.Rhs = gol.IndexExpr{X: sx, Index: ididx}

			loop.Body = gol.BlockStmt{List: []gol.StmtNode{asn}}

			list = append(list, loop)
		}

		return append(list, gol.NL{})
	} else if len(si.spec.filter) > 0 {
		asn := gol.AssignStmt{Token: gol.AssignAdd}
		asn.Lhs = idquery
		asn.Rhs = gol.CallExpr{Fun: gol.SelectorExpr{
			X:   gol.SelectorExpr{X: idrecv, Sel: gol.Ident{si.spec.filter}},
			Sel: gol.Ident{"ToSQL"},
		}}

		var asn1 gol.StmtNode = gol.NoOp{}
		if g.fclose {
			asn := gol.AssignStmt{Token: gol.AssignAdd}
			asn.Lhs = idquery
			asn.Rhs = gol.RawStringLit(`)`)
			asn1 = asn
		}

		asn2 := gol.AssignStmt{Token: gol.AssignDefine}
		asn2.Lhs = idparams
		asn2.Rhs = gol.CallExpr{Fun: gol.SelectorExpr{
			X:   gol.SelectorExpr{X: idrecv, Sel: gol.Ident{si.spec.filter}},
			Sel: gol.Ident{"Params"},
		}}
		return gol.StmtList{gol.DeclStmt{decl}, gol.NL{}, asn, asn1, asn2, gol.NL{}}
	}
	return gol.DeclStmt{decl}
}

func (g *generator) querydefaults(si *specinfo) (stmt gol.StmtNode) {
	var list gol.StmtList
	if l := si.spec.limit; l != nil && l.value > 0 && len(l.field) > 0 {
		sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{l.field}}

		asn := gol.AssignStmt{Token: gol.Assign}
		asn.Lhs = sx
		asn.Rhs = gol.IntLit(l.value)

		ifzero := gol.IfStmt{}
		ifzero.Cond = gol.BinaryExpr{X: sx, Op: gol.BinaryEql, Y: gol.IntLit(0)}
		ifzero.Body = gol.BlockStmt{List: []gol.StmtNode{asn}}
		list = append(list, ifzero)
	}

	if o := si.spec.offset; o != nil && o.value > 0 && len(o.field) > 0 {
		sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{o.field}}

		asn := gol.AssignStmt{Token: gol.Assign}
		asn.Lhs = sx
		asn.Rhs = gol.IntLit(o.value)

		ifzero := gol.IfStmt{}
		ifzero.Cond = gol.BinaryExpr{X: sx, Op: gol.BinaryEql, Y: gol.IntLit(0)}
		ifzero.Body = gol.BlockStmt{List: []gol.StmtNode{asn}}
		list = append(list, ifzero)
	}

	if len(list) == 0 {
		return gol.NoOp{}
	}

	list = append(list, gol.NL{})
	return list
}

func (g *generator) queryexec(si *specinfo) (stmt gol.StmtNode) {
	args := gol.ArgsList{List: idquery}
	if len(g.insx) > 0 || len(si.spec.filter) > 0 || (si.spec.kind == speckindInsert && si.spec.rel.rec.isslice) {
		args.AddExprs(idparams)
		args.Ellipsis = true
	} else {
		args.AddExprs(g.queryargs...)
		if args.Len() > 3 {
			args.OnePerLine = 2
		}
	}

	// produce c.Exec( ... ) call
	{
		if si.spec.kind != speckindSelect && si.spec.returning == nil && si.spec.result == nil {

			if rafield := si.spec.rowsaffected; rafield != nil {
				// call exec & assign res, err
				asn := gol.AssignStmt{Token: gol.AssignDefine}
				asn.Lhs = gol.ExprList{idres, iderr}
				asn.Rhs = gol.CallExpr{Fun: sxexec, Args: args}

				// check err
				iferr := gol.IfStmt{}
				iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
				iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

				// call RowsAffected & assing i64, err
				asn2 := gol.AssignStmt{Token: gol.AssignDefine}
				asn2.Lhs = gol.ExprList{idi64, iderr}
				asn2.Rhs = callresrowsaffected

				// check err
				iferr2 := gol.IfStmt{}
				iferr2.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
				iferr2.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

				//
				asn3 := gol.AssignStmt{Token: gol.Assign}
				asn3.Lhs = gol.SelectorExpr{X: idrecv, Sel: gol.Ident{rafield.name}}
				if rafield.kind == kindint64 {
					asn3.Rhs = idi64
				} else {
					args := gol.ArgsList{List: idi64}
					asn3.Rhs = gol.CallExpr{Fun: gol.Ident{typekind2string[rafield.kind]}, Args: args}
				}

				return gol.StmtList{asn, iferr, asn2, iferr2, gol.NL{}, asn3}
			} else {
				asn := gol.AssignStmt{Token: gol.AssignDefine}
				asn.Lhs = gol.ExprList{idblank, iderr}
				asn.Rhs = gol.CallExpr{Fun: sxexec, Args: args}
				return asn
			}
		}
	}

	// produce c.QueryRow( ... ) call
	{
		rec := si.spec.rel.rec
		if si.spec.result != nil {
			rec = si.spec.result.rec
		}

		if !rec.isslice && !rec.isiter {
			asn := gol.AssignStmt{Token: gol.AssignDefine}
			asn.Lhs = idrow
			asn.Rhs = gol.CallExpr{Fun: sxqueryrow, Args: args}
			//return gol.StmtList{asn, gol.NL{}}
			return gol.StmtList{asn}
		}
	}

	// produce c.Query( ... ) call with if-err-check, defer-rows-close, and
	// for-rows-next loop to scan the rows
	{
		asn := gol.AssignStmt{Token: gol.AssignDefine}
		asn.Lhs = gol.ExprList{idrows, iderr}
		asn.Rhs = gol.CallExpr{Fun: sxquery, Args: args}

		iferr := gol.IfStmt{}
		iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
		iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

		defclose := gol.DeferStmt{}
		defclose.Call = gol.CallExpr{Fun: sxrowsclose}

		fornext := g.fornext(si)
		return gol.StmtList{asn, iferr, defclose, gol.NL{}, fornext}
	}
	return stmt
}

func (g *generator) returnerr(si *specinfo, errx gol.ExprNode) gol.ReturnStmt {
	if si.spec.erh == nil {
		return gol.ReturnStmt{errx}
	}
	if si.spec.erh.isinfo {
		lit := gol.StructLit{Type: sxerrorinfo, Compact: true}
		lit.Elems = []gol.FieldElement{
			{"Error", iderr},
			{"Query", idquery},
			{"SpecKind", gol.StringLit(si.spec.kind.String())},
			{"SpecName", gol.StringLit(si.spec.name)},
			{"SpecValue", idrecv},
		}
		litptr := gol.UnaryExpr{Op: gol.UnaryAmp, X: lit}

		sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{si.spec.erh.name}}
		fun := gol.SelectorExpr{X: sx, Sel: gol.Ident{"HandleErrorInfo"}}
		call := gol.CallExpr{Fun: fun, Args: gol.ArgsList{List: litptr}}
		return gol.ReturnStmt{call}

		// TODO if errx is not iderr, then errx is probably a CallFunc and
		// should first be executed and it's result passed into HandleErrorInfo..
	}
	sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{si.spec.erh.name}}
	fun := gol.SelectorExpr{X: sx, Sel: gol.Ident{"HandleError"}}
	call := gol.CallExpr{Fun: fun, Args: gol.ArgsList{List: errx}}
	return gol.ReturnStmt{call}
}

func (g *generator) fornext(si *specinfo) (stmt gol.ForStmt) {
	stmt.Clause = gol.ForCondition{callrowsnext}
	// scan & assign error
	{
		var args gol.ArgsList
		if len(g.scanargs) > 2 {
			args.OnePerLine = 1
		}
		args.AddExprs(g.scanargs...)
		stmt.Body.List = append(stmt.Body.List, g.scaninits...)

		asn := gol.AssignStmt{Token: gol.AssignDefine}
		asn.Lhs = iderr
		asn.Rhs = gol.CallExpr{Fun: sxrowsscan, Args: args}
		stmt.Body.List = append(stmt.Body.List, asn)
	}

	// check error & newline
	{
		iferr := gol.IfStmt{}
		iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
		iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}
		stmt.Body.List = append(stmt.Body.List, iferr, gol.NL{})
	}

	// append OR iterate
	{
		rec := si.spec.rel.rec
		fieldname := si.spec.rel.name
		if si.spec.result != nil {
			rec = si.spec.result.rec
			fieldname = si.spec.result.name
		}

		if rec.isafterscanner {
			// call afterscan
			sx := gol.SelectorExpr{X: gol.Ident{"v"}, Sel: idafterscan}
			afterscan := gol.ExprStmt{gol.CallExpr{Fun: sx}}
			stmt.Body.List = append(stmt.Body.List, afterscan)
		}

		if rec.isiter {
			var call gol.CallExpr
			if len(rec.itermethod) > 0 {
				call = gol.CallExpr{Fun: gol.SelectorExpr{
					X:   gol.SelectorExpr{X: idrecv, Sel: gol.Ident{fieldname}},
					Sel: gol.Ident{rec.itermethod}},
					Args: gol.ArgsList{List: gol.Ident{"v"}},
				}
			} else {
				call = gol.CallExpr{Fun: gol.SelectorExpr{
					X:   idrecv,
					Sel: gol.Ident{fieldname}},
					Args: gol.ArgsList{List: gol.Ident{"v"}},
				}
			}

			asn := gol.AssignStmt{Token: gol.AssignDefine}
			asn.Lhs = iderr
			asn.Rhs = call

			iferr := gol.IfStmt{}
			iferr.Init = asn
			iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
			iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}
			stmt.Body.List = append(stmt.Body.List, iferr)
		} else {
			appnd := gol.CallExpr{Fun: gol.Ident{"append"}}
			appnd.Args = gol.ArgsList{List: gol.ExprList{
				gol.SelectorExpr{X: idrecv, Sel: gol.Ident{fieldname}},
				gol.Ident{"v"},
			}}

			asn := gol.AssignStmt{Token: gol.Assign}
			asn.Lhs = gol.SelectorExpr{X: idrecv, Sel: gol.Ident{fieldname}}
			asn.Rhs = appnd
			stmt.Body.List = append(stmt.Body.List, asn)
		}
	}
	return stmt
}

func (g *generator) returnstmt(si *specinfo) (stmt gol.StmtNode) {
	if si.spec.rowsaffected != nil {
		return gol.ReturnStmt{idnil}
	}

	if si.spec.kind == speckindSelect || si.spec.returning != nil {
		rel := si.spec.rel

		// does the record type need pre-allocation? and is it imported?
		if rel.rec.base.isimported && (rel.rec.isslice || rel.rec.ispointer) {
			g.addimport(rel.rec.base.pkgpath, rel.rec.base.pkgname, rel.rec.base.pkglocal)
		}

		if rel.rec.isslice || rel.rec.isarray || rel.rec.isiter {
			if si.spec.erh != nil && si.spec.erh.isinfo {
				asn := gol.AssignStmt{Token: gol.AssignDefine}
				asn.Lhs = iderr
				asn.Rhs = callrowserr

				iferr := gol.IfStmt{}
				iferr.Init = asn
				iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
				iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

				return gol.StmtList{iferr, gol.ReturnStmt{idnil}}
			}
			return g.returnerr(si, callrowserr)
		} else {
			var args gol.ArgsList
			var list gol.StmtList // result

			if si.spec.selkind > selectfrom {
				fx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{rel.name}}
				args.AddExprs(gol.UnaryExpr{Op: gol.UnaryAmp, X: fx})
			} else {
				if len(g.scanargs) > 2 {
					args.OnePerLine = 1
				}
				args.AddExprs(g.scanargs...)
				list = append(list, g.scaninits...)
			}

			if !rel.rec.isafterscanner {
				call := gol.CallExpr{Fun: sxrowscan, Args: args}
				if si.spec.erh != nil && si.spec.erh.isinfo {
					asn := gol.AssignStmt{Token: gol.AssignDefine}
					asn.Lhs = iderr
					asn.Rhs = call

					iferr := gol.IfStmt{}
					iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
					iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

					list = append(list, asn, iferr, gol.ReturnStmt{idnil})
				} else {
					list = append(list, g.returnerr(si, call))
				}
			} else {
				// scan & assign error
				asn := gol.AssignStmt{Token: gol.AssignDefine}
				asn.Lhs = iderr
				asn.Rhs = gol.CallExpr{Fun: sxrowscan, Args: args}

				// check error
				iferr := gol.IfStmt{}
				iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
				iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

				// call afterscan
				sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{rel.name}}
				sx = gol.SelectorExpr{X: sx, Sel: idafterscan}
				afterscan := gol.ExprStmt{gol.CallExpr{Fun: sx}}

				// call afterscan
				ret := gol.ReturnStmt{idnil}

				// done
				list = append(list, asn, iferr, gol.NL{}, afterscan, ret)
			}

			return list
		}
	}

	// result field
	if si.spec.result != nil {
		rel := si.spec.result
		// does the record type need pre-allocation? and is it imported?
		if rel.rec.base.isimported && (rel.rec.isslice || rel.rec.ispointer) {
			g.addimport(rel.rec.base.pkgpath, rel.rec.base.pkgname, rel.rec.base.pkglocal)
		}

		if rel.rec.isslice || rel.rec.isarray || rel.rec.isiter {
			if si.spec.erh != nil && si.spec.erh.isinfo {
				asn := gol.AssignStmt{Token: gol.AssignDefine}
				asn.Lhs = iderr
				asn.Rhs = callrowserr

				iferr := gol.IfStmt{}
				iferr.Init = asn
				iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
				iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

				return gol.StmtList{iferr, gol.ReturnStmt{idnil}}
			}
			return g.returnerr(si, callrowserr)
		} else {
			var args gol.ArgsList
			if len(g.scanargs) > 2 {
				args.OnePerLine = 1
			}
			args.AddExprs(g.scanargs...)

			var list gol.StmtList // result
			list = append(list, g.scaninits...)

			if !rel.rec.isafterscanner {
				call := gol.CallExpr{Fun: sxrowscan, Args: args}
				if si.spec.erh != nil && si.spec.erh.isinfo {
					asn := gol.AssignStmt{Token: gol.AssignDefine}
					asn.Lhs = iderr
					asn.Rhs = call

					iferr := gol.IfStmt{}
					iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
					iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

					list = append(list, asn, iferr, gol.ReturnStmt{idnil})
				} else {
					list = append(list, g.returnerr(si, call))
				}
			} else {
				// scan & assing error
				asn := gol.AssignStmt{Token: gol.AssignDefine}
				asn.Lhs = iderr
				asn.Rhs = gol.CallExpr{Fun: sxrowscan, Args: args}

				// check error
				iferr := gol.IfStmt{}
				iferr.Cond = gol.BinaryExpr{X: iderr, Op: gol.BinaryNeq, Y: idnil}
				iferr.Body = gol.BlockStmt{List: []gol.StmtNode{g.returnerr(si, iderr)}}

				// call afterscan
				sx := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{rel.name}}
				sx = gol.SelectorExpr{X: sx, Sel: idafterscan}
				afterscan := gol.ExprStmt{gol.CallExpr{Fun: sx}}

				// call afterscan
				ret := gol.ReturnStmt{idnil}

				// done
				list = append(list, asn, iferr, gol.NL{}, afterscan, ret)
			}

			return list
		}
	}

	return g.returnerr(si, iderr)
}

func (g *generator) rectype(rec recordtype) gol.TypeNode {
	if rec.base.isimported {
		return gol.QualifiedIdent{rec.base.pkgname, rec.base.name}
	}
	return gol.Ident{rec.base.name}
}

func (g *generator) pathelemtype(pe *pathelem) gol.TypeNode {
	if pe.isimported {
		return gol.QualifiedIdent{pe.typepkgname, pe.typename}
	}
	return gol.Ident{pe.typename}
}

func (g *generator) addimport(path, name, local string) {
	// check that the package path hasn't yet been added to the imports
	for _, spec := range g.imports.Specs {
		if string(spec.Path) == path {
			return
		}
	}

	// if the local name is the same as the package name set it to empty
	if local == name {
		local = ""
	}

	spec := gol.ImportSpec{Path: gol.StringLit(path), Name: gol.Ident{local}}
	g.imports.Specs = append(g.imports.Specs, spec)
}

func (g *generator) sqlnode(si *specinfo) (node gol.Node) {
	switch si.spec.kind {
	case speckindInsert:
		return g.sqlinsert(si)
	case speckindUpdate:
		return g.sqlupdate(si)
	case speckindSelect:
		switch si.spec.selkind {
		case selectcount:
			return g.sqlselectcount(si)
		case selectexists, selectnotexists:
			return g.sqlselectexists(si)
		}
		return g.sqlselect(si)
	case speckindDelete:
		return g.sqldelete(si)
	}
	return node
}

// sqlinsert builds and returns an sql.InsertStatement.
func (g *generator) sqlinsert(si *specinfo) (stmt sql.InsertStatement) {
	var src sql.InsertSource
	if si.spec.rel.rec.isslice {
		src.Values = &sql.ValuesClause{}
	} else {
		src.Values = &sql.ValuesClause{g.inputparams}
	}

	stmt.Head.Table = g.sqlrelid(si.spec.rel.relid)
	stmt.Head.Columns = g.inputcolumns
	stmt.Head.Overriding = overridingkind2sqlclause[si.spec.override]
	stmt.Head.Source = src
	//stmt.Head.Source.Select = nil
	//stmt.Tail.OnConflict = nil
	//stmt.Tail.Returning = nil
	return stmt
}

func (g *generator) sqlupdate(si *specinfo) (updstmt sql.UpdateStatement) {
	// TODO
	return updstmt
}

// sqlselect builds and returns an sql.SelectStatement.
func (g *generator) sqlselect(si *specinfo) (selstmt sql.SelectStatement) {
	selstmt.Columns = g.outputcolumns // columns
	selstmt.Table = g.sqlrelid(si.spec.rel.relid)
	selstmt.Join = g.sqljoin(si.spec.join)
	selstmt.Where = g.sqlwhere(si.spec.where)
	selstmt.Order = g.sqlorderby(si.spec)
	selstmt.Limit = g.sqllimit(si.spec)
	selstmt.Offset = g.sqloffset(si.spec)
	return selstmt
}

// sqldelete builds and returns an sql.DeleteStatement.
func (g *generator) sqldelete(si *specinfo) (delstmt sql.DeleteStatement) {
	delstmt.Table = g.sqlrelid(si.spec.rel.relid)
	delstmt.Using = g.sqlusing(si.spec.join)
	delstmt.Where = g.sqlwhere(si.spec.where)
	delstmt.Returning = sql.ReturningClause(g.outputcolumns) //returning
	return delstmt
}

// sqlselectexists builds and returns an sql.SelectExistsStatement.
func (g *generator) sqlselectexists(si *specinfo) (selstmt sql.SelectExistsStatement) {
	selstmt.Table = g.sqlrelid(si.spec.rel.relid)
	selstmt.Join = g.sqljoin(si.spec.join)
	selstmt.Not = si.spec.selkind == selectnotexists
	if si.spec.filter == "" {
		selstmt.Where = g.sqlwhere(si.spec.where)
		selstmt.Order = g.sqlorderby(si.spec)
		selstmt.Limit = g.sqllimit(si.spec)
		selstmt.Offset = g.sqloffset(si.spec)
	} else {
		selstmt.Open = true
		g.fclose = true
	}
	return selstmt
}

// sqlselectcount builds and returns an sql.SelectCountStatement.
func (g *generator) sqlselectcount(si *specinfo) (selstmt sql.SelectCountStatement) {
	selstmt.Table = g.sqlrelid(si.spec.rel.relid)
	selstmt.Join = g.sqljoin(si.spec.join)
	if si.spec.filter == "" {
		selstmt.Where = g.sqlwhere(si.spec.where)
		selstmt.Order = g.sqlorderby(si.spec)
		selstmt.Offset = g.sqloffset(si.spec)
	}
	return selstmt
}

func (g *generator) sqlwhere(w *whereblock) (where sql.WhereClause) {
	if w != nil {
		sel := gol.SelectorExpr{X: idrecv, Sel: gol.Ident{w.name}}
		where.SearchCondition, _ = g.sqlsearchcond(w.items, sel, false)
	}
	return where
}

func (g *generator) sqlsearchcond(items []*predicateitem, sel gol.SelectorExpr, parenthesized bool) (list sql.BoolValueExprList, count int) {
	for _, item := range items {
		count += 1

		var x sql.BoolValueExpr
		switch node := item.node.(type) {
		// nested: recurse
		case *nestedpredicate:
			var ncount int

			sel := gol.SelectorExpr{X: sel, Sel: gol.Ident{node.name}}
			x, ncount = g.sqlsearchcond(node.items, sel, true)

			count += ncount - 1

		// 3-arg predicate: build & return
		case *betweenpredicate:
			p := sql.BetweenPredicate{}
			p.Predicand = g.sqlcolref(node.colid)
			if x, ok := node.x.(colid); ok {
				p.LowEnd = g.sqlcolref(x)
			} else {
				// assume node.x is *paramfield
				p.LowEnd = g.sqlparam()
			}
			if y, ok := node.y.(colid); ok {
				p.HighEnd = g.sqlcolref(y)
			} else {
				// assume node.x is *paramfield
				p.HighEnd = g.sqlparam()
			}
			x = p

		// 2-arg predicates: prepare first, then build & return
		case *fieldpredicate, *columnpredicate:
			var (
				lhs     sql.ValueExpr
				rhs     sql.ValueExpr
				pred    predicate
				qua     quantifier
				field   string
				coltype string
			)

			// prepare
			switch node := node.(type) {
			case *fieldpredicate:
				pred = node.pred
				qua = node.qua
				lhs = g.sqlcolref(node.colid)
				rhs = g.sqlparam()
				if len(node.modfunc) > 0 {
					li := sql.RoutineInvocation{}
					li.Name = string(node.modfunc)
					li.Args = []sql.ValueExpr{lhs}
					lhs = li

					ri := sql.RoutineInvocation{}
					ri.Name = string(node.modfunc)
					ri.Args = []sql.ValueExpr{rhs}
					rhs = ri
				}

				if qua > 0 {
					coltype = node.coltype
				}

				field = node.field.name // needed for isin/notin predicates
			case *columnpredicate:
				pred = node.pred
				qua = node.qua
				lhs = g.sqlcolref(node.colid)
				if !node.colid2.isempty() {
					rhs = g.sqlcolref(node.colid2)
				} else if len(node.lit) > 0 {
					rhs = sql.Literal{node.lit}
				}
			}

			// quantifier?
			if qua > 0 {
				if len(coltype) > 0 {
					cast := sql.CastExpr{}
					cast.Expr = rhs
					cast.Type = coltype + "[]"
					rhs = cast
				}
				qx := sql.QuantifiedExpr{}
				qx.Qua = quantifier2sqlquantifier[qua]
				qx.Expr = rhs
				rhs = qx
			}

			// build & return
			switch pred {
			case iseq, noteq, noteq2, islt, isgt, islte, isgte:
				p := sql.ComparisonPredicate{}
				p.Cmp = predicate2sqlcmpop[pred]
				p.LPredicand = lhs
				p.RPredicand = rhs
				x = p
			case islike, notlike:
				p := sql.LikePredicate{}
				p.Not = (pred == notlike)
				p.Predicand = lhs
				p.Pattern = rhs
				x = p
			case isilike, notilike:
				p := sql.ILikePredicate{}
				p.Not = (pred == notilike)
				p.Predicand = lhs
				p.Pattern = rhs
				x = p
			case issimilar, notsimilar:
				p := sql.SimilarPredicate{}
				p.Not = (pred == notsimilar)
				p.Predicand = lhs
				p.Pattern = rhs
				x = p
			case isdistinct, notdistinct:
				p := sql.DistinctPredicate{}
				p.Not = (pred == notdistinct)
				p.LPredicand = lhs
				p.RPredicand = rhs
				x = p
			case ismatch, ismatchi, notmatch, notmatchi:
				p := sql.RegexPredicate{}
				p.Op = predicate2sqlregexop[pred]
				p.Predicand = lhs
				p.Pattern = rhs
				x = p
			case isin, notin:
				sx := gol.SelectorExpr{X: sel, Sel: gol.Ident{field}}
				g.insx = append(g.insx, sx)
				g.nparam -= 1  // ordinal param won't be used directly
				g.asvar = true // queryString should be var not const

				num := strconv.Itoa(len(g.insx))
				arg1 := gol.Ident{"len" + num}
				//arg2 := gol.BinaryExpr{X: gol.Ident{"pos" + num}, Op: gol.BinaryAdd, Y: gol.IntLit(1)}
				arg2 := gol.Ident{"pos" + num}

				call := callinvaluelist
				call.Args = gol.ArgsList{List: gol.ExprList{arg1, arg2}}

				p := sql.InPredicate{}
				p.Not = (pred == notin)
				p.Predicand = lhs
				p.ValueList = sql.HostValue{gol.RawStringInsertExpr{call}}
				x = p
			case istrue, nottrue, isfalse, notfalse, isunknown, notunknown:
				p := sql.TruthPredicate{}
				p.Not = (pred == nottrue || pred == notfalse || pred == notunknown)
				p.Truth = predicate2sqltruth[pred]
				p.Predicand = lhs
				x = p
			case isnull, notnull:
				p := sql.NullPredicate{}
				p.Not = (pred == notnull)
				p.Predicand = lhs
				x = p
			default:
				// no predicate, assume lhs is by itself a boolean value expression
				if p, ok := lhs.(sql.BoolValueExpr); ok {
					x = p
				}
			}
		}

		switch item.op {
		default: // initial
			list.Initial = x
		case booland:
			list.Items = append(list.Items, sql.AND{Operand: x})
		case boolor:
			list.Items = append(list.Items, sql.OR{Operand: x})
		}

	}

	if count > 2 {
		list.ListStyle = true
	}

	list.Parenthesized = parenthesized
	return list, count
}

func (g *generator) sqlorderby(spec *typespec) (order sql.OrderClause) {
	if spec.orderby == nil {
		return order
	}

	for _, item := range spec.orderby.items {
		by := sql.OrderBy{}
		by.Column = g.sqlcolref(item.col)
		by.Desc = (item.dir == orderdesc)
		order.List = append(order.List, by)
	}
	return order
}

func (g *generator) sqlusing(jb *joinblock) (using sql.UsingClause) {
	if jb == nil {
		return using
	}

	using.List = []sql.TableExpr{g.sqlrelid(jb.rel)}
	for _, item := range jb.items {
		var join sql.TableJoin
		join.Type = jointype2sqljointype[item.typ]
		join.Rel = g.sqlrelid(item.rel)
		join.Cond = g.sqljoincond(item.conds)
		using.List = append(using.List, join)
	}
	return using
}

func (g *generator) sqljoin(jb *joinblock) (jc sql.JoinClause) {
	if jb == nil {
		return jc
	}

	for _, item := range jb.items {
		var join sql.TableJoin
		join.Type = jointype2sqljointype[item.typ]
		join.Rel = g.sqlrelid(item.rel)
		join.Cond = g.sqljoincond(item.conds)
		jc.List = append(jc.List, join)
	}
	return jc
}

func (g *generator) sqljoincond(items []*predicateitem) (cond sql.JoinCondition) {
	if len(items) > 0 {
		list, _ := g.sqlsearchcond(items, gol.SelectorExpr{}, false)
		list.ListStyle = false

		cond.SearchCondition = list
	}
	return cond
}

// sqllimit generates and returns an sql.LimitClause based on the given spec's "limit" field.
func (g *generator) sqllimit(spec *typespec) (limit sql.LimitClause) {
	if spec.limit != nil {
		if len(spec.limit.field) > 0 {
			limit.Value = g.sqlparam()
		} else if spec.limit.value > 0 {
			limit.Value = sql.LimitUint(spec.limit.value)
		}
		return limit
	}

	// In case the spec doesn't have a "limit" field, but the relation
	// field handles only a single record (i.e. it's not a slice, etc.)
	// then, by default, generate a `LIMIT 1` clause.
	if r := spec.rel.rec; !r.isarray && !r.isslice && !r.isiter {
		limit.Value = sql.LimitInt(1)
		return limit
	}
	return limit
}

// sqloffset generates and returns an sql.OffsetClause based on the given spec's "offset" field.
func (g *generator) sqloffset(spec *typespec) (offset sql.OffsetClause) {
	if spec.offset != nil {
		if len(spec.offset.field) > 0 {
			offset.Value = g.sqlparam()
		} else if spec.offset.value > 0 {
			offset.Value = sql.OffsetUint(spec.offset.value)
		}
		return offset
	}
	return offset
}

func (g *generator) sqlrelid(id relid) sql.Ident {
	return sql.Ident{
		Name:  sql.Name(id.name),
		Qual:  id.qual,
		Alias: id.alias,
	}
}

func (g *generator) sqlcolexpr(fc *fieldcolumn) sql.ValueExpr {
	id := g.sqlcolref(fc.colid)
	// TODO
	//if f.UseCOALESCE || (f.IsNULLable && canCoalesce && !f.Type.IsPointer) {
	//	coalesce := sqlang.Coalesce{}
	//	coalesce.A = col
	//	coalesce.B = _sql_empty_literal(f)

	//	if (f.ColTypeIsEnum || f.ColTypeName == "uuid") && len(f.COALESCEValue) == 0 {
	//		coalesce.A = sqlang.CastExpr{
	//			X:    coalesce.A,
	//			Type: sqlang.Literal("text"),
	//		}
	//	}
	//	return coalesce
	//}
	return id
}

func (g *generator) sqlcolref(id colid) sql.ColumnReference {
	return sql.ColumnReference{
		Qual: id.qual,
		Name: sql.Name(id.name),
	}
}

func (g *generator) sqlparam() sql.OrdinalParameterSpec {
	g.nparam += 1
	return sql.OrdinalParameterSpec{g.nparam}
}

// declarevar reports whether the queryString value should be declared as a var or as a const.
func (g *generator) declarevar(si *specinfo) bool {
	return g.asvar || len(si.spec.filter) > 0 ||
		((si.spec.kind == speckindInsert || si.spec.kind == speckindUpdate) &&
			si.spec.rel.rec.isslice)
}

var overridingkind2sqlclause = map[overridingkind]sql.OverridingClause{
	overridingsystem: "SYSTEM",
	overridinguser:   "USER",
}

var predicate2sqlcmpop = map[predicate]sql.CMPOP{
	iseq:   sql.EQUAL,
	noteq:  sql.NOT_EQUAL,
	noteq2: sql.NOT_EQUAL2,
	islt:   sql.LESS_THAN,
	isgt:   sql.GREATER_THAN,
	islte:  sql.LESS_THAN_EQUAL,
	isgte:  sql.GREATER_THAN_EQUAL,
}

var predicate2sqlregexop = map[predicate]sql.REGEXOP{
	ismatch:   sql.MATCH,
	ismatchi:  sql.MATCH_CI,
	notmatch:  sql.NOT_MATCH,
	notmatchi: sql.NOT_MATCH_CI,
}

var predicate2sqltruth = map[predicate]sql.TRUTH{
	isunknown:  sql.UNKNOWN,
	notunknown: sql.UNKNOWN,
	istrue:     sql.TRUE,
	nottrue:    sql.TRUE,
	isfalse:    sql.FALSE,
	notfalse:   sql.FALSE,
}

var quantifier2sqlquantifier = map[quantifier]sql.QUANTIFIER{
	quantany:  sql.ANY,
	quantsome: sql.SOME,
	quantall:  sql.ALL,
}

var jointype2sqljointype = map[jointype]sql.JoinType{
	joinleft:  sql.JoinLeft,
	joinright: sql.JoinRight,
	joinfull:  sql.JoinFull,
	joincross: sql.JoinCross,
}

var gotyp2coltyp2converter = map[string]map[string]gol.SelectorExpr{
	gotypbools:   {"boolean[]": gol.SelectorExpr{ /*TODO*/ }},
	gotypstrings: {"text[]": gol.SelectorExpr{X: gol.Ident{"gosql"}, Sel: gol.Ident{"StringSliceToTextArray"}}},
	gotypints: {
		"integer[]":  gol.SelectorExpr{X: gol.Ident{"gosql"}, Sel: gol.Ident{"IntSliceToIntArray"}},
		"smallint[]": gol.SelectorExpr{X: gol.Ident{"gosql"}, Sel: gol.Ident{"IntSliceToIntArray"}},
		"bigint[]":   gol.SelectorExpr{X: gol.Ident{"gosql"}, Sel: gol.Ident{"IntSliceToIntArray"}},
	},
	gotypint8s: {
		"integer[]":  gol.SelectorExpr{ /*TODO*/ },
		"smallint[]": gol.SelectorExpr{ /*TODO*/ },
		"bigint[]":   gol.SelectorExpr{ /*TODO*/ },
	},
	gotypint16s: {
		"integer[]":  gol.SelectorExpr{ /*TODO*/ },
		"smallint[]": gol.SelectorExpr{ /*TODO*/ },
		"bigint[]":   gol.SelectorExpr{ /*TODO*/ },
	},
	gotypint32s: {
		"integer[]":  gol.SelectorExpr{ /*TODO*/ },
		"smallint[]": gol.SelectorExpr{ /*TODO*/ },
		"bigint[]":   gol.SelectorExpr{ /*TODO*/ },
	},
	gotypint64s: {
		"integer[]":  gol.SelectorExpr{ /*TODO*/ },
		"smallint[]": gol.SelectorExpr{ /*TODO*/ },
		"bigint[]":   gol.SelectorExpr{ /*TODO*/ },
	},
}
