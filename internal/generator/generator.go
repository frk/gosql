package generator

import (
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/frk/gosql/internal/analysis"
	"github.com/frk/gosql/internal/postgres"

	GO "github.com/frk/ast/golang"
	SQL "github.com/frk/ast/sqlang"
)

var _ = log.Println

const (
	gosqlPkgPath = `github.com/frk/gosql`
	pgsqlPkgPath = `github.com/frk/gosql/pgsql`

	filePreamble = ` DO NOT EDIT. This file was generated by "github.com/frk/gosql".`
)

type Config struct {
	FilterColumnKeyTag       string
	FilterColumnKeySeparator string
	FilterColumnKeyBase      bool
	QuoteIdentifiers         bool
}

func Write(f io.Writer, pkgName string, targets []*postgres.TargetInfo, conf Config) error {
	var (
		file         = new(GO.File)
		imports      = new(GO.ImportDecl)
		fmtFilterKey = makeFilterKeyFormatter(conf)
		fmtColIdent  = makeColIdentFormatter(conf)
		importGosql  bool
	)
	for _, info := range targets {
		g := new(generator)
		g.conf = conf
		g.info = info
		g.file = file
		g.imports = imports
		g.fmtFilterKey = fmtFilterKey
		g.fmtColIdent = fmtColIdent
		g.queryRecv = GO.Ident{"q"}
		g.inputPKeys = inputPKeys(info)

		switch s := info.Struct.(type) {
		case *analysis.QueryStruct:
			buildQueryCode(g, s)
			importGosql = true
		case *analysis.FilterStruct:
			buildFilterCode(g, s)
		}
	}

	if importGosql {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: gosqlPkgPath})
	}
	sortImports(imports)

	file.PkgName = pkgName
	file.Preamble = GO.LineComment{filePreamble}
	file.Imports = []GO.ImportDeclNode{imports}
	return GO.Write(file, f)
}

type generator struct {
	// The generator configuration.
	conf Config
	// Info on the target type for which the generator will build code.
	info *postgres.TargetInfo
	// The target file to be build by the generator.
	file *GO.File
	// The associated file's import declaration.
	imports *GO.ImportDecl
	// fmtFilterKey returns a string representation of the given field
	// filter to be used as the key for a filter's column map.
	fmtFilterKey func(*postgres.FieldFilter) string
	// fmtColIdent returns a string representation of the given column identifier.
	fmtColIdent func(analysis.ColIdent) string
	// The set of parameter numbers mapped by their fields. (lazily initialized by makeParamSpec)
	paramSet map[analysis.FieldPtr]int
	// The number of parameters.
	paramNum int
	// If true, the query string should be declared as a var instead of const.
	declVar bool
	// If true, the SQL query needs to be closed (with right parentheses)
	// after the filter's been added.
	closeFilter bool
	// The query method's receiver identifier.
	queryRecv GO.Ident

	inputPKeys []*postgres.FieldWrite
	// The root node for the fields to be passed as input to the query (Exec|Query|QueryRow).
	inputRoot GO.ExprNode
	// List of arguments to be passed to the query (Exec|Query|QueryRow).
	inputArgs []GO.ExprNode
	// List of selector expressions for fields that containin slices that
	// will be used as input for [NOT] IN clauses.
	inputSliceArgs []GO.SelectorExpr
	// The list of target columns to be set by the sql query (INSERT|UPDATE).
	inputCols      SQL.NameGroup
	inputColsPKeys SQL.NameGroup
	// The list of input value expressions to be assigned to the target
	// columns by the sql query (INSERT|UPDATE).
	inputVals      SQL.ValueExprList
	inputValsPKeys SQL.ValueExprList

	// The root node for the fields to be passed as output destination (Scan).
	outputRoot GO.ExprNode
	outputVar  GO.ExprNode
	// The list of pointer initializations for scanning nested fields.
	outputInit GO.StmtList
	// List of arguments to be passed as output destination (Scan).
	outputArgs []GO.ExprNode
	// The list of output value expressions to be returned by the sql query
	// either (SELECT) or (INSERT|UPDATE|DELETE) with the RETURNING clause.
	outputVals SQL.ValueExprList
	// Indicates whether or not the output type impelments the AfterScan method.
	outputIsAfterScanner bool
	// Indicates whether or not the output type is an iterator.
	outputIsIter bool
	// If set, will hold the name of the iterator method of the output type.
	outputIterMethod string
	// Indicates whether or not the output will be scanned into the input.
	outputToInput bool

	// The primary sqlString value node.
	sqlMainNode SQL.Node
	// Holds SQL string to be appended to the primary sqlString node.
	sqlTailNode SQL.Node
	// The WHERE clause for the sqlString (UPDATE|SELECT|DELETE).
	whereClause SQL.WhereClause
	// The ORDER BY clause for the sqlString (SELECT).
	orderClause SQL.OrderClause
	// The LIMIT clause for the sqlString (SELECT).
	limitClause SQL.LimitClause
	// The OFFSET clause for the sqlString (SELECT).
	offsetClause SQL.OffsetClause
	// The ON CONFLICT clause for the sqlString (INSERT).
	onConflictClause *SQL.OnConflictClause
	// The list of table joins to be used in a DELETE-USING, UPDATE-FROM, SELECT-FROM clause.
	tableJoinSlice []SQL.TableJoin

	// The declaration of the queryString constant or variable.
	queryStringDecl GO.DeclNode
	// The complete set of statements that produce the final queryString value.
	queryStringStmt GO.StmtNode
	// The set of statements that produce the params variable from the filter field..
	queryFilterParams GO.StmtNode
	// The list of statements that handles the fallback values for the limit and offset fields.
	queryLimitAndOffsetFallback GO.StmtList
	// The set of statements that produce the main query call (Exec|Query|QueryRow).
	queryCallStmt GO.StmtNode
	// The set of statements that handle the result of the queryCallStmt.
	queryResultStmt GO.StmtNode
}

// tableExprSlice converts the tableJoinSlice ([]SQL.TableJoinSlice) to a []SQL.TableExpr.
func (g *generator) tableExprSlice() []SQL.TableExpr {
	s := make([]SQL.TableExpr, len(g.tableJoinSlice))
	for i := 0; i < len(s); i++ {
		s[i] = g.tableJoinSlice[i]
	}
	return s
}

// buildQueryCode builds code for the given QueryStruct.
func buildQueryCode(g *generator, qs *analysis.QueryStruct) {
	buildQueryInput(g, qs)
	buildQueryOutput(g, qs)

	buildQuerySQLString(g, qs)
	buildQueryStringDecl(g, qs)

	if qs.IsInsertOrUpdateSlice() {
		buildQueryStringForSliceInsertOrUpdate(g, qs)
	} else if len(g.inputSliceArgs) > 0 {
		buildQueryStringForSliceArgs(g, qs)
	} else if qs.Filter != nil {
		buildQueryStringForFilter(g, qs)
	} else {
		g.queryStringStmt = GO.StmtList{GO.DeclStmt{g.queryStringDecl}, GO.NL{}}
	}

	buildQueryFilterParams(g, qs)
	buildQueryLimitOffsetFallback(g, qs)

	if qs.IsWithoutOutput() {
		buildQueryCallExec(g, qs)
		if qs.RowsAffected != nil {
			buildQueryResultRowsAffected(g, qs)
		} else {
			g.queryResultStmt = makeErrorReturnStmt(g, qs, GO.Ident{"err"})
		}
	} else if qs.IsSingleOutput() {
		buildQueryCallQueryRow(g, qs)
		buildQueryResultRowScan(g, qs)
	} else {
		buildQueryCallQuery(g, qs)
		buildQueryResultRowsScan(g, qs)
	}

	// put it all together
	method := GO.MethodDecl{}
	method.Recv.Name.Name = "q"
	method.Recv.Type = GO.PointerRecvType{qs.TypeName}
	method.Name.Name = "Exec"
	method.Type.Params = GO.ParamList{{Names: GO.Ident{"c"}, Type: GO.QualifiedIdent{"gosql", "Conn"}}}
	method.Type.Results = GO.ParamList{{Type: GO.Ident{"error"}}}
	method.Body.List = []GO.StmtNode{
		g.queryStringStmt,
		g.queryLimitAndOffsetFallback,
		g.queryFilterParams,
		g.queryCallStmt,
		g.queryResultStmt,
	}

	g.file.Decls = append(g.file.Decls, method)
}

// buildQueryInput
func buildQueryInput(g *generator, qs *analysis.QueryStruct) {
	buildQueryInputRoot(g, qs)
	// build input for INSERT / UPDATE query
	buildQueryInputTargetColumns(g, qs)
	buildQueryInputTargetValues(g, qs)
	buildQueryInputSourceFields(g, qs)
	// prepare input for the WHERE clause
	buildQueryInputWhereStruct(g, qs)
	buildQueryInputPKeyFields(g, qs)
	// prepare input for the LIMIT clause
	buildQueryInputLimitField(g, qs)
	// prepare input for the OFFSET clause
	buildQueryInputOffsetField(g, qs)
}

// buildQueryInputRoot
func buildQueryInputRoot(g *generator, qs *analysis.QueryStruct) {
	g.inputRoot = GO.ExprNode(GO.SelectorExpr{X: g.queryRecv, Sel: GO.Ident{qs.Rel.FieldName}})
	if qs.Rel.Type.IsSlice {
		g.inputRoot = GO.Ident{"v"}
	}
}

// buildQueryInputTargetColumns builds the target columns for an INSERT or UPDATE query.
func buildQueryInputTargetColumns(g *generator, qs *analysis.QueryStruct) {
	for _, fw := range g.info.Writes {
		g.inputCols = append(g.inputCols, SQL.Name(fw.Column.Name))
	}

	if qs.IsUpdateSlice() {
		for _, fw := range g.inputPKeys {
			g.inputColsPKeys = append(g.inputColsPKeys, SQL.Name(fw.Column.Name))
		}
	}

}

// buildQueryInputTargetValues builds the list of value expressions for
// an INSERT or UPDATE query, that will be used to set the target columns.
func buildQueryInputTargetValues(g *generator, qs *analysis.QueryStruct) {
	if len(g.info.Writes) == 0 {
		return
	}

	for _, fw := range g.info.Writes {
		if canUseDefault(qs, fw.Field) {
			g.inputVals = append(g.inputVals, SQL.DEFAULT)
			continue
		}

		if qs.IsUpdateSlice() {
			col := SQL.ColumnIdent{}
			col.Name = SQL.Name(fw.Column.Name)
			col.Qual = "x"

			cast := SQL.CastExpr{}
			cast.Expr = col
			cast.Type = fw.Column.Type.NameFmt
			g.inputVals = append(g.inputVals, cast)
			continue
		}

		var expr SQL.ValueExpr
		expr = makeParamSpec(g, fw.Field)
		expr = addNULLIFCallExpr(expr, fw.Field, fw.Column, fw.Valuer)
		g.inputVals = append(g.inputVals, expr)
	}

	if qs.IsUpdateSlice() {
		for _, fw := range g.inputPKeys {
			g.inputValsPKeys = append(g.inputValsPKeys, makeParamSpec(g, fw.Field))
		}
	}
}

// buildQueryInputSourceFields builds a list of GO field selector expressions
// that will be passed as arguments to the query executing function.
func buildQueryInputSourceFields(g *generator, qs *analysis.QueryStruct) {
	if len(g.info.Writes) == 0 {
		return
	}

	for _, fw := range g.info.Writes {
		if canUseDefault(qs, fw.Field) {
			continue
		}

		fx := g.inputRoot
		for _, node := range fw.Field.Selector {
			fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{node.Name}}
		}
		fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{fw.Field.Name}}
		fx = addConverterCallExpr(g, fx, fw.Valuer)
		g.inputArgs = append(g.inputArgs, fx)
	}
}

// buildQueryInputWhereStruct builds the input for a WHERE clause from the given analysis.WhereStruct.
func buildQueryInputWhereStruct(g *generator, qs *analysis.QueryStruct) {
	if qs.Where == nil {
		return
	}

	sx := GO.SelectorExpr{X: g.queryRecv, Sel: GO.Ident{qs.Where.FieldName}}
	buildQueryInputWhereConditional(g, g.info.Where, sx)
}

// buildQueryInputWhereConditional builds the input for a WHERE clause from the given []postgres.WhereConditional.
func buildQueryInputWhereConditional(g *generator, conds []postgres.WhereConditional, sx GO.SelectorExpr) {
	for _, wc := range conds {
		switch cond := wc.(type) {
		case *postgres.FieldConditional:
			buildQueryInputFieldConditional(g, cond, sx)
		case *postgres.BetweenConditional:
			buildQueryInputBetweenConditional(g, cond, sx)
		case *postgres.NestedConditional:
			sxNested := GO.SelectorExpr{X: sx, Sel: GO.Ident{cond.FieldName}}
			buildQueryInputWhereConditional(g, cond.Conditionals, sxNested)
		}
	}
}

// buildQueryInputFieldConditional
func buildQueryInputFieldConditional(g *generator, cond *postgres.FieldConditional, sx GO.SelectorExpr) {
	if cond.Predicate.IsArray() {
		return
	}

	expr := GO.ExprNode(GO.SelectorExpr{X: sx, Sel: GO.Ident{cond.FieldName}})
	expr = addConverterCallExpr(g, expr, cond.Valuer)
	g.inputArgs = append(g.inputArgs, expr)
}

// buildQueryInputBetweenConditional
func buildQueryInputBetweenConditional(g *generator, cond *postgres.BetweenConditional, sx GO.SelectorExpr) {
	sx = GO.SelectorExpr{X: sx, Sel: GO.Ident{cond.FieldName}}
	if lower, ok := cond.LowerBound.(*postgres.FieldConditional); ok {
		buildQueryInputFieldConditional(g, lower, sx)
	}
	if upper, ok := cond.UpperBound.(*postgres.FieldConditional); ok {
		buildQueryInputFieldConditional(g, upper, sx)
	}
}

// buildQueryInputPKeyFields builds the input for a WHERE clause using the primary key(s).
func buildQueryInputPKeyFields(g *generator, qs *analysis.QueryStruct) {
	if qs.IsUpdateWithPKeys() {
		for _, fw := range g.inputPKeys {
			fx := GO.ExprNode(g.inputRoot)
			for _, node := range fw.Field.Selector {
				fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{node.Name}}
			}
			fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{fw.Field.Name}}
			g.inputArgs = append(g.inputArgs, fx)
		}
	}
}

// buildQueryInputLimitField
func buildQueryInputLimitField(g *generator, qs *analysis.QueryStruct) {
	if qs.Limit == nil || len(qs.Limit.Name) == 0 {
		return
	}

	sx := GO.SelectorExpr{X: g.queryRecv, Sel: GO.Ident{qs.Limit.Name}}
	g.inputArgs = append(g.inputArgs, sx)
}

// buildQueryInputOffsetField
func buildQueryInputOffsetField(g *generator, qs *analysis.QueryStruct) {
	if qs.Offset == nil || len(qs.Offset.Name) == 0 {
		return
	}

	sx := GO.SelectorExpr{X: g.queryRecv, Sel: GO.Ident{qs.Offset.Name}}
	g.inputArgs = append(g.inputArgs, sx)
}

// buildQueryOutput
func buildQueryOutput(g *generator, qs *analysis.QueryStruct) {
	if len(g.info.Reads) == 0 && !qs.IsSelectCountOrExists() {
		return
	}

	buildQueryOutputRoot(g, qs)
	buildQueryOutputInitRoot(g, qs)
	buildQueryOutputInitFields(g, qs)
	buildQueryOutputTargetFields(g, qs)
	buildQueryOutputSourceColumns(g, qs)
}

// buildQueryOutputRoot
func buildQueryOutputRoot(g *generator, qs *analysis.QueryStruct) {
	typ := qs.Rel.Type
	name := qs.Rel.FieldName
	if qs.Result != nil {
		typ = qs.Result.Type
		name = qs.Result.FieldName
	}

	g.outputRoot = GO.ExprNode(GO.SelectorExpr{X: g.queryRecv, Sel: GO.Ident{name}})
	g.outputVar = g.outputRoot
	if typ.IsSlice && canSkipRelInit(qs) {
		g.outputVar = GO.IndexExpr{X: g.outputVar, Index: GO.Ident{"i"}}
	} else if typ.IsSlice || typ.IsIter {
		g.outputVar = GO.Ident{"v"}
	}

	g.outputIsAfterScanner = typ.IsAfterScanner
	g.outputIsIter = typ.IsIter
	g.outputIterMethod = typ.IterMethod
	g.outputToInput = (qs.IsInsertOrUpdateSlice() && qs.Result == nil)
}

// buildQueryOutputInitRoot
func buildQueryOutputInitRoot(g *generator, qs *analysis.QueryStruct) {
	if canSkipRelInit(qs) {
		return
	}

	typ := qs.Rel.Type
	if qs.Result != nil {
		typ = qs.Result.Type
	}
	if typ.Base.IsImported {
		addImport(g, typ.Base.PkgPath, typ.Base.PkgName, typ.Base.PkgLocal)
	}

	var (
		typeNode = makeRelTypeNode(typ)
		rootinit GO.StmtNode
	)
	if !typ.IsSlice && !typ.IsIter && typ.IsPointer {
		g.outputInit = append(g.outputInit, GO.NL{})

		init := GO.AssignStmt{Token: GO.Assign}
		init.Lhs = g.outputRoot
		init.Rhs = GO.CallNewExpr{typeNode}
		rootinit = init
	} else if (typ.IsSlice || typ.IsIter) && typ.IsPointer {
		init := GO.AssignStmt{Token: GO.AssignDefine}
		init.Lhs = g.outputVar
		init.Rhs = GO.CallNewExpr{typeNode}
		rootinit = init
	} else if (typ.IsSlice || typ.IsIter) && !typ.IsPointer {
		init := GO.VarDecl{}
		init.Spec = GO.ValueSpec{Names: GO.Ident{"v"}, Type: typeNode}
		rootinit = GO.DeclStmt{init}
	}
	if rootinit != nil {
		g.outputInit = append(g.outputInit, rootinit)
	}
}

// buildQueryOutputInitFields
func buildQueryOutputInitFields(g *generator, qs *analysis.QueryStruct) {
	if canSkipRelInit(qs) {
		return
	}

	// done is used to keep track of pointer fields whose
	// initialization statements have already been created
	var done = make(map[string]bool)

	for _, fr := range g.info.Reads {
		key := "" // key for the done map

		fx := g.outputVar
		for _, node := range fr.Field.Selector {
			key += node.Name

			fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{node.Name}}
			if node.IsPointer && !done[key] {
				if node.IsImported {
					addImport(g, node.TypePkgPath, node.TypePkgName, node.TypePkgLocal)
				}

				init := GO.AssignStmt{Token: GO.Assign}
				init.Lhs = fx
				init.Rhs = GO.CallNewExpr{makeSelTypeNode(node)}
				g.outputInit = append(g.outputInit, init)

				done[key] = true
			}
		}
	}
}

// buildQueryOutputTargetFields
func buildQueryOutputTargetFields(g *generator, qs *analysis.QueryStruct) {
	if qs.IsSelectCountOrExists() {
		fx := GO.UnaryExpr{Op: GO.UnaryAmp, X: g.outputRoot}
		g.outputArgs = append(g.outputArgs, fx)
		return
	}

	for _, fr := range g.info.Reads {
		fx := g.outputVar
		for _, node := range fr.Field.Selector {
			fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{node.Name}}
		}

		fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{fr.Field.Name}}
		fx = GO.UnaryExpr{Op: GO.UnaryAmp, X: fx}
		fx = addConverterCallExpr(g, fx, fr.Scanner)
		g.outputArgs = append(g.outputArgs, fx)
	}
}

// buildQueryOutputSourceColumns builds the list of columns to be returned by the query.
func buildQueryOutputSourceColumns(g *generator, qs *analysis.QueryStruct) {
	if len(g.info.Reads) == 0 {
		return
	}

	for _, fr := range g.info.Reads {
		var expr SQL.ValueExpr
		expr = makeColRef(fr.ColIdent)
		expr = addCoalesceCallExpr(expr, fr.Field, fr.Column, fr.Scanner)
		g.outputVals = append(g.outputVals, expr)
	}
}

// buildQueryLimitOffsetFallback
func buildQueryLimitOffsetFallback(g *generator, qs *analysis.QueryStruct) {
	if limit := qs.Limit; limit != nil && limit.Value > 0 && len(limit.Name) > 0 {
		sx := GO.SelectorExpr{X: g.queryRecv, Sel: GO.Ident{limit.Name}}

		assign := GO.AssignStmt{Token: GO.Assign}
		assign.Lhs = sx
		assign.Rhs = GO.IntLit(limit.Value)

		ifzero := GO.IfStmt{}
		ifzero.Cond = GO.BinaryExpr{X: sx, Op: GO.BinaryEql, Y: GO.IntLit(0)}
		ifzero.Body = GO.BlockStmt{List: []GO.StmtNode{assign}}
		g.queryLimitAndOffsetFallback = append(g.queryLimitAndOffsetFallback, ifzero)
	}

	if offset := qs.Offset; offset != nil && offset.Value > 0 && len(offset.Name) > 0 {
		sx := GO.SelectorExpr{X: g.queryRecv, Sel: GO.Ident{offset.Name}}

		assign := GO.AssignStmt{Token: GO.Assign}
		assign.Lhs = sx
		assign.Rhs = GO.IntLit(offset.Value)

		ifzero := GO.IfStmt{}
		ifzero.Cond = GO.BinaryExpr{X: sx, Op: GO.BinaryEql, Y: GO.IntLit(0)}
		ifzero.Body = GO.BlockStmt{List: []GO.StmtNode{assign}}
		g.queryLimitAndOffsetFallback = append(g.queryLimitAndOffsetFallback, ifzero)
	}

	if len(g.queryLimitAndOffsetFallback) > 0 {
		g.queryLimitAndOffsetFallback = append(g.queryLimitAndOffsetFallback, GO.NL{})
	} else {
		g.queryLimitAndOffsetFallback = GO.StmtList{GO.NoOp{}}
	}
}

// addConverterCallExpr
func addConverterCallExpr(g *generator, x GO.ExprNode, converter string) GO.ExprNode {
	if len(converter) > 0 {
		addImport(g, pgsqlPkgPath, "", "")
		sel := GO.SelectorExpr{X: GO.Ident{"pgsql"}, Sel: GO.Ident{converter}}
		return GO.CallExpr{Fun: sel, Args: GO.ArgsList{List: x}}
	}
	return x
}

// addCoalesceCallExpr
func addCoalesceCallExpr(x SQL.ValueExpr, f *analysis.FieldInfo, c *postgres.Column, scanner string) SQL.ValueExpr {
	if f.UseCoalesce || c.IsNULLable() && (f.Type.IsScanner == false && scanner == "") {
		if lit, ok := c.Type.ZeroValueLiteral(); ok {
			cast := SQL.CastExpr{}
			cast.Expr = SQL.Literal{lit}
			cast.Type = c.Type.NameFmt

			coalesce := SQL.Coalesce{}
			coalesce.A = x
			coalesce.B = cast
			return coalesce
		}
	}
	return x
}

// addNULLIFCallExpr
func addNULLIFCallExpr(x SQL.ValueExpr, f *analysis.FieldInfo, c *postgres.Column, valuer string) SQL.ValueExpr {
	if c.IsNULLable() && (f.Type.IsValuer == false && valuer == "") {
		if lit, ok := c.Type.ZeroValueLiteral(); ok {
			nullif := SQL.NULLIF{}
			nullif.Value = x
			nullif.Expr = SQL.Literal{lit}

			cast := SQL.CastExpr{}
			cast.Expr = nullif
			cast.Type = c.Type.NameFmt
			return cast
		}
	}
	return x
}

////////////////////////////////////////////////////////////////////////////////
// Filter Specific Code Builders
//

// buildFilterCode builds code for the given FilterStruct.
func buildFilterCode(g *generator, fs *analysis.FilterStruct) {
	mapid := buildFilterColumnMap(g, fs)
	buildFilterMethodInit(g, fs, mapid)
	buildFilterMethodsForColumns(g, fs, mapid)
	buildFilterMethodBoolOp(g, fs, "And")
	buildFilterMethodBoolOp(g, fs, "Or")
}

// buildFilterColumnMap
func buildFilterColumnMap(g *generator, fs *analysis.FilterStruct) (mapid GO.Ident) {
	mapid.Name = "_" + fs.TypeName + "_colmap"

	elems := make([]GO.KeyElement, 0)
	keyset := make(map[string]struct{}) // use to ensure unique map keys
	for _, filter := range g.info.Filters {
		key := g.fmtFilterKey(filter)
		if _, ok := keyset[key]; ok {
			continue
		}
		keyset[key] = struct{}{}

		elem := GO.KeyElement{}
		elem.Key = GO.StringLit(key)
		elem.Value = GO.RawStringLit(g.fmtColIdent(filter.ColIdent))

		elems = append(elems, elem)
	}

	maplit := GO.MapLit{}
	maplit.Type = GO.MapType{Key: GO.Ident{"string"}, Value: GO.Ident{"string"}}
	maplit.Elems = elems

	mapvar := GO.VarDecl{}
	mapvar.Spec = GO.ValueSpec{Names: mapid, Values: maplit}

	g.file.Decls = append(g.file.Decls, mapvar)
	return mapid
}

// buildFilterMethodInit
func buildFilterMethodInit(g *generator, fs *analysis.FilterStruct, mapid GO.Ident) {
	var (
		recv = GO.Ident{"f"}                       // receiver's name
		ctor = GO.Ident{fs.FilterConstructor.Name} // filter constructor field's name
		selx = GO.SelectorExpr{X: GO.SelectorExpr{X: recv, Sel: ctor}, Sel: GO.Ident{"Init"}}
	)

	args := GO.ExprList{mapid, GO.StringLit("")}
	if ts := fs.TextSearch; ts != nil {
		args[1] = GO.RawStringLit(g.fmtColIdent(ts.ColIdent))
	}

	methodecl := GO.MethodDecl{}
	methodecl.Recv.Name = recv
	methodecl.Recv.Type = GO.PointerRecvType{fs.TypeName}
	methodecl.Name.Name = "Init"
	methodecl.Body.List = []GO.StmtNode{GO.ExprStmt{
		GO.CallExpr{Fun: selx, Args: GO.ArgsList{List: args}},
	}}

	g.file.Decls = append(g.file.Decls, methodecl)
}

// buildFilterMethodsForColumns
func buildFilterMethodsForColumns(g *generator, fs *analysis.FilterStruct, mapid GO.Ident) {
	var (
		recv  = GO.Ident{"f"}                       // the receiver name
		oper  = GO.Ident{"op"}                      // the operator argument name
		value = GO.Ident{"val"}                     // the value argument name
		ctor  = GO.Ident{fs.FilterConstructor.Name} // filter constructor field's name
		selx  = GO.SelectorExpr{X: GO.SelectorExpr{X: recv, Sel: ctor}, Sel: GO.Ident{"Col"}}
	)

	for _, ff := range g.info.Filters {
		methodecl := GO.MethodDecl{}

		// the method's receiver
		methodecl.Recv.Name = recv
		methodecl.Recv.Type = GO.PointerRecvType{fs.TypeName}

		// the method's name
		for _, node := range ff.Field.Selector {
			// TODO(mkopriva): reconsider concatenating without prejudice, might
			// be better to omit embedded fields, so that the method name match
			// the corresponding field selection ability.
			//
			// Keep in mind that if the above is implemented, it will be
			// important to keep track of the field "promotion hierarchy",
			// i.e. two fields with the same name, nested in embedded fields,
			// but at different depths...

			// If the field's nested, concatenate the names of the parent fields.
			methodecl.Name.Name += node.Name
		}
		methodecl.Name.Name += ff.Field.Name

		// skip if name is reserved
		if _, ok := reservedFilterMethodNames[methodecl.Name.Name]; ok {
			continue
		}

		// add import if necessary
		if typ := ff.Field.Type; typ.IsImported {
			addImport(g, typ.PkgPath, typ.PkgName, typ.PkgLocal)
		}

		// the method's input and output arguments
		methodecl.Type.Params = GO.ParamList{
			{Names: oper, Type: GO.Ident{"string"}},
			{Names: value, Type: GO.Ident{string(ff.Field.Type.Literal())}},
		}
		methodecl.Type.Results = GO.ParamList{{Type: GO.PointerType{GO.Ident{fs.TypeName}}}}

		// the method's body
		methodecl.Body.List = []GO.StmtNode{
			GO.ExprStmt{GO.CallExpr{
				Fun: selx,
				Args: GO.ArgsList{List: GO.ExprList{
					GO.RawStringLit(g.fmtColIdent(ff.ColIdent)),
					oper, value}},
			}},
			GO.ReturnStmt{recv},
		}

		g.file.Decls = append(g.file.Decls, methodecl)
	}
}

// buildFilterMethodBoolOp
func buildFilterMethodBoolOp(g *generator, fs *analysis.FilterStruct, name string) {
	var (
		nilVal = GO.Ident{"nil"}
		recv   = GO.Ident{"f"}                       // method's receiver name
		rtyp   = GO.PointerRecvType{fs.TypeName}     // method's reciever type
		nest   = GO.Ident{"nest"}                    // method's argument name
		ctor   = GO.Ident{fs.FilterConstructor.Name} // filter constructor field's name
		selx   = GO.SelectorExpr{X: GO.SelectorExpr{X: recv, Sel: ctor}, Sel: GO.Ident{name}}
	)

	methodecl := GO.MethodDecl{}
	methodecl.Recv.Name = recv
	methodecl.Recv.Type = rtyp
	methodecl.Name.Name = name

	// the method's input and output arguments
	methodecl.Type.Params = GO.ParamList{
		{Names: nest, Type: GO.FuncType{Params: GO.ParamList{{Type: rtyp}}}},
	}
	methodecl.Type.Results = GO.ParamList{{Type: rtyp}}

	// the method's body
	methodecl.Body.List = []GO.StmtNode{
		GO.IfStmt{
			Cond: GO.BinaryExpr{X: nest, Op: GO.BinaryEql, Y: nilVal},
			Body: GO.BlockStmt{[]GO.StmtNode{
				GO.ExprStmt{GO.CallExpr{
					Fun:  selx,
					Args: GO.ArgsList{List: nilVal},
				}},
				GO.ReturnStmt{recv},
			}},
		},
		GO.ExprStmt{GO.CallExpr{
			Fun: selx,
			Args: GO.ArgsList{List: GO.ExprList{GO.FuncLit{
				Type: GO.FuncType{},
				Body: GO.BlockStmt{[]GO.StmtNode{
					GO.ExprStmt{GO.CallExpr{
						Fun:  nest,
						Args: GO.ArgsList{List: recv},
					}},
				}},
			}}},
		}},
		GO.ReturnStmt{recv},
	}

	g.file.Decls = append(g.file.Decls, methodecl)
}

////////////////////////////////////////////////////////////////////////////////
// SQL Specific Functions
//

func buildQuerySQLString(g *generator, qs *analysis.QueryStruct) {
	buildSQLTableJoinSlice(g, qs)
	buildSQLWhereClause(g, qs)
	buildSQLOrderClause(g, qs)
	buildSQLLimitClause(g, qs)
	buildSQLOffsetClause(g, qs)
	buildSQLOnConflictClause(g, qs)

	switch qs.Kind {
	case analysis.QueryKindInsert:
		buildSQLInsertStatement(g, qs)
	case analysis.QueryKindUpdate:
		buildSQLUpdateStatement(g, qs)
	case analysis.QueryKindSelect:
		buildSQLSelectStatement(g, qs)
	case analysis.QueryKindSelectCount:
		buildSQLSelectCountStatement(g, qs)
	case analysis.QueryKindSelectExists, analysis.QueryKindSelectNotExists:
		buildSQLSelectExistsStatement(g, qs)
	case analysis.QueryKindDelete:
		buildSQLDeleteStatement(g, qs)
	}
}

////////////////////////////////////////////////////////////////////////////////
// SQL Statement Builder Functions
//

// buildSQLInsertStatement builds an SQL.InsertStatement.
func buildSQLInsertStatement(g *generator, qs *analysis.QueryStruct) {
	stmt := SQL.InsertStatement{}
	stmt.Head.Table = makeRelIdent(qs.Rel.Id)
	stmt.Head.Columns = g.inputCols
	if qs.Override != nil {
		stmt.Head.Overriding = sqlOverridingClause[qs.Override.Kind]
	}
	if qs.Rel.Type.IsSlice {
		stmt.Head.Source.Values = &SQL.ValuesClause{}
	} else {
		stmt.Head.Source.Values = &SQL.ValuesClause{g.inputVals}
	}

	tail := SQL.InsertTail{}
	tail.OnConflict = g.onConflictClause
	tail.Returning = SQL.ReturningClause(g.outputVals)
	if qs.Rel.Type.IsSlice && (len(g.outputVals) > 0 || g.onConflictClause != nil) {
		g.sqlTailNode = tail
	} else {
		stmt.Tail = tail
	}

	g.sqlMainNode = stmt
}

// buildSQLUpdateStatement builds an SQL.UpdateStatement.
func buildSQLUpdateStatement(g *generator, qs *analysis.QueryStruct) {
	stmt := SQL.UpdateStatement{}
	stmt.Head.Table = makeRelIdent(qs.Rel.Id)
	stmt.Head.Set.Targets = g.inputCols
	stmt.Head.Set.Values.Exprs = g.inputVals
	if qs.Join != nil {
		stmt.Head.From.List = []SQL.TableExpr{makeRelIdent(qs.Join.Relation.RelIdent)}
		stmt.Head.From.List = append(stmt.Head.From.List, g.tableExprSlice()...)
	}

	if qs.Rel.Type.IsSlice {
		stmt.Head.From.List = append(stmt.Head.From.List, SQL.ValuesListClausePartial{})

		columns := append(g.inputCols, g.inputColsPKeys...)
		alias := SQL.ValuesListAliasPartial{Alias: "x", Columns: columns}
		tail := SQL.UpdateTail{Where: g.whereClause}
		g.sqlTailNode = SQL.NodeList{alias, tail}
		g.sqlMainNode = stmt
		return
	}

	if qs.Filter != nil && len(g.outputVals) > 0 {
		tail := SQL.UpdateTail{}
		tail.Returning = SQL.ReturningClause(g.outputVals)
		g.sqlTailNode = tail
		g.sqlMainNode = stmt
		return
	}

	stmt.Tail.Where = g.whereClause
	stmt.Tail.Returning = SQL.ReturningClause(g.outputVals)
	g.sqlMainNode = stmt
}

// buildSQLSelectStatement builds and returns an SQL.SelectStatement.
func buildSQLSelectStatement(g *generator, qs *analysis.QueryStruct) {
	stmt := SQL.SelectStatement{}
	stmt.Columns = g.outputVals // columns
	stmt.Table = makeRelIdent(qs.Rel.Id)
	if qs.Join != nil {
		stmt.Join.List = append(stmt.Join.List, g.tableJoinSlice...)
	}
	stmt.Where = g.whereClause
	stmt.Order = g.orderClause
	stmt.Limit = g.limitClause
	stmt.Offset = g.offsetClause
	g.sqlMainNode = stmt
}

// buildSQLDeleteStatement builds an SQL.DeleteStatement.
func buildSQLDeleteStatement(g *generator, qs *analysis.QueryStruct) {
	stmt := SQL.DeleteStatement{}
	stmt.Table = makeRelIdent(qs.Rel.Id)

	if qs.Join != nil {
		stmt.Using.List = []SQL.TableExpr{makeRelIdent(qs.Join.Relation.RelIdent)}
		stmt.Using.List = append(stmt.Using.List, g.tableExprSlice()...)
	}

	stmt.Where = g.whereClause
	stmt.Returning = SQL.ReturningClause(g.outputVals) //returning
	g.sqlMainNode = stmt
}

// buildSQLSelectCountStatement builds an SQL.SelectCountStatement.
func buildSQLSelectCountStatement(g *generator, qs *analysis.QueryStruct) {
	stmt := SQL.SelectCountStatement{}
	stmt.Table = makeRelIdent(qs.Rel.Id)

	if qs.Join != nil {
		stmt.Join.List = append(stmt.Join.List, g.tableJoinSlice...)
	}

	if qs.Filter == nil {
		stmt.Where = g.whereClause
		stmt.Order = g.orderClause
		stmt.Offset = g.offsetClause
	}

	g.sqlMainNode = stmt
}

// buildSQLSelectExistsStatement builds an SQL.SelectExistsStatement.
func buildSQLSelectExistsStatement(g *generator, qs *analysis.QueryStruct) {
	stmt := SQL.SelectExistsStatement{}
	stmt.Table = makeRelIdent(qs.Rel.Id)
	stmt.Not = (qs.Kind == analysis.QueryKindSelectNotExists)

	if qs.Join != nil {
		stmt.Join.List = append(stmt.Join.List, g.tableJoinSlice...)
	}

	if qs.Filter == nil {
		stmt.Where = g.whereClause
		stmt.Order = g.orderClause
		stmt.Limit = g.limitClause
		stmt.Offset = g.offsetClause
	} else {
		stmt.Open = true
		g.closeFilter = true
	}

	g.sqlMainNode = stmt
}

////////////////////////////////////////////////////////////////////////////////
// SQL Clause Builder Functions
//

// buildSQLLimitClause builds an SQL.LimitClause.
func buildSQLLimitClause(g *generator, qs *analysis.QueryStruct) {
	if qs.Limit == nil {
		// In case the QueryStruct doesn't have a "limit" field, but the relation
		// field handles only a single record (i.e. it's not a slice, etc.)
		// then, by default, generate a `LIMIT 1` clause.
		if typ := qs.Rel.Type; !typ.IsArray && !typ.IsSlice && !typ.IsIter {
			g.limitClause.Value = SQL.LimitInt(1)
		}
		return
	}

	if len(qs.Limit.Name) > 0 {
		g.limitClause.Value = makeParamSpec(g, qs.Limit)
	} else if qs.Limit.Value > 0 {
		g.limitClause.Value = SQL.LimitUint(qs.Limit.Value)
	}
}

// buildSQLOffsetClause builds an SQL.OffsetClause.
func buildSQLOffsetClause(g *generator, qs *analysis.QueryStruct) {
	if qs.Offset == nil {
		return
	}

	if len(qs.Offset.Name) > 0 {
		g.offsetClause.Value = makeParamSpec(g, qs.Offset)
	} else if qs.Offset.Value > 0 {
		g.offsetClause.Value = SQL.OffsetUint(qs.Offset.Value)
	}
}

// buildSQLOrderClause builds an SQL.OrderClause.
func buildSQLOrderClause(g *generator, qs *analysis.QueryStruct) {
	if qs.OrderBy == nil {
		return
	}

	for _, item := range qs.OrderBy.Items {
		order := SQL.OrderBy{}
		order.Column = makeColRef(item.ColIdent)
		order.Desc = (item.Direction == analysis.OrderDesc)
		order.NullsFirst = (item.Nulls == analysis.NullsFirst)
		g.orderClause.List = append(g.orderClause.List, order)
	}
}

// buildSQLOnConflictClause
func buildSQLOnConflictClause(g *generator, qs *analysis.QueryStruct) {
	if qs.Kind != analysis.QueryKindInsert || g.info.Conflict == nil {
		return
	}

	g.onConflictClause = new(SQL.OnConflictClause)

	// conflict target
	switch ct := g.info.Conflict.Target.(type) {
	case *postgres.ConflictIndex:
		target := SQL.ConflictIndex{}
		target.Expr = ct.Expression
		target.Pred = ct.Predicate
		g.onConflictClause.Target = target
	case *postgres.ConflictConstraint:
		g.onConflictClause.Target = SQL.ConflictConstraint(ct.Name)
	}

	// conflict action
	if len(g.info.Conflict.Update) > 0 {
		action := &SQL.ConflictAction{}
		action.Update.Compact = len(g.info.Conflict.Update) == 1
		for _, col := range g.info.Conflict.Update {
			action.Update.Columns = append(action.Update.Columns, SQL.Name(col.Name))
		}
		g.onConflictClause.Action = action
	}
}

// buildSQLWhereClause builds the SQL.WhereClause
func buildSQLWhereClause(g *generator, qs *analysis.QueryStruct) {
	if qs.IsUpdateWithPKeys() {
		list := SQL.BoolValueExprList{}
		for i, fw := range g.info.PKeys {
			predicate := SQL.ComparisonPredicate{}
			predicate.Cmp = sqlCMPOP[analysis.IsEQ]
			predicate.LPredicand = makeColRef(fw.ColIdent)
			predicate.RPredicand = makeParamSpec(g, fw.Field)

			if qs.Rel.Type.IsSlice {
				col := SQL.ColumnIdent{Qual: "x", Name: SQL.Name(fw.ColIdent.Name)}
				predicate.RPredicand = SQL.CastExpr{Expr: col, Type: fw.Column.Type.NameFmt}
			}

			if i == 0 {
				list.Initial = predicate
			} else {
				list.Items = append(list.Items, SQL.AND{Operand: predicate})
			}
		}
		g.whereClause.SearchCondition = list
		return
	}

	if len(g.info.Where) > 0 {
		sel := GO.SelectorExpr{X: g.queryRecv, Sel: GO.Ident{qs.Where.FieldName}}
		g.whereClause.SearchCondition, _ = makeSQLBoolValueExprList(g, g.info.Where, sel, false)
	}
}

// buildSQLTableJoinSlice builds a slice of SQL.TableJoin values.
func buildSQLTableJoinSlice(g *generator, qs *analysis.QueryStruct) {
	if qs.Join == nil {
		return
	}

	for i, dir := range qs.Join.Directives {
		conds := make([]postgres.WhereConditional, len(g.info.Joins[i]))
		for j := 0; j < len(g.info.Joins[i]); j++ {
			conds[j] = g.info.Joins[i][j]
		}

		searchCond, _ := makeSQLBoolValueExprList(g, conds, GO.SelectorExpr{}, false)
		searchCond.ListStyle = false

		join := SQL.TableJoin{}
		join.Type = sqlJoinType[dir.JoinType]
		join.Rel = makeRelIdent(dir.RelIdent)
		join.Cond.SearchCondition = searchCond
		g.tableJoinSlice = append(g.tableJoinSlice, join)
	}
}

// makeSQLBoolValueExprList builds and returns an SQL.BoolValueExprList.
func makeSQLBoolValueExprList(g *generator, conds []postgres.WhereConditional, sx GO.SelectorExpr, parenthesized bool) (list SQL.BoolValueExprList, count int) {
	var boolean analysis.Boolean
	for i := 0; i < len(conds); i++ {
		if cond, ok := conds[i].(*postgres.Boolean); ok {
			boolean = cond.Value
			continue
		}

		count += 1

		var expr SQL.BoolValueExpr
		switch cond := conds[i].(type) {
		case *postgres.NestedConditional:
			sx := GO.SelectorExpr{X: sx, Sel: GO.Ident{cond.FieldName}}
			vx, num := makeSQLBoolValueExprList(g, cond.Conditionals, sx, true)
			expr, count = vx, count+num-1
		case *postgres.BetweenConditional:
			expr = makeSQLBetweenPredicate(g, cond)
		case *postgres.FieldConditional, *postgres.ColumnConditional:
			var (
				lhs        SQL.ValueExpr
				rhs        SQL.ValueExpr
				pred       analysis.Predicate
				qua        analysis.Quantifier
				fieldName  string
				columnType string
			)

			// prepare
			switch cond := cond.(type) {
			case *postgres.FieldConditional:
				fieldName = cond.FieldName // needed for isin/notin predicates
				pred = cond.Predicate
				qua = cond.Quantifier
				lhs = makeColRef(cond.ColIdent)
				rhs = makeParamSpec(g, cond)

				if len(cond.FuncName) > 0 {
					lhsFuncCall := SQL.RoutineInvocation{}
					lhsFuncCall.Name = string(cond.FuncName)
					lhsFuncCall.Args = []SQL.ValueExpr{lhs}
					lhs = lhsFuncCall

					rhsFuncCall := SQL.RoutineInvocation{}
					rhsFuncCall.Name = string(cond.FuncName)
					rhsFuncCall.Args = []SQL.ValueExpr{rhs}
					rhs = rhsFuncCall
				}
				if cond.Quantifier > 0 {
					columnType = cond.Column.Type.NameFmt
				}

			case *postgres.ColumnConditional:
				pred = cond.Predicate
				qua = cond.Quantifier
				lhs = makeColRef(cond.LHSColIdent)
				if !cond.RHSColIdent.IsEmpty() {
					rhs = makeColRef(cond.RHSColIdent)
				} else if len(cond.RHSLiteral) > 0 {
					rhs = SQL.Literal{cond.RHSLiteral}
				}
			}

			if qua > 0 {
				if len(columnType) > 0 {
					cast := SQL.CastExpr{}
					cast.Expr = rhs
					cast.Type = columnType + "[]"
					rhs = cast
				}

				qx := SQL.QuantifiedExpr{}
				qx.Qua = sqlQUANTIFIER[qua]
				qx.Expr = rhs
				rhs = qx
			}

			// build & return
			switch pred {
			case analysis.IsEQ, analysis.NotEQ, analysis.NotEQ2, analysis.IsLT, analysis.IsGT, analysis.IsLTE, analysis.IsGTE:
				predicate := SQL.ComparisonPredicate{}
				predicate.Cmp = sqlCMPOP[pred]
				predicate.LPredicand = lhs
				predicate.RPredicand = rhs
				expr = predicate
			case analysis.IsLike, analysis.NotLike:
				predicate := SQL.LikePredicate{}
				predicate.Not = (pred == analysis.NotLike)
				predicate.Predicand = lhs
				predicate.Pattern = rhs
				expr = predicate
			case analysis.IsILike, analysis.NotILike:
				predicate := SQL.ILikePredicate{}
				predicate.Not = (pred == analysis.NotILike)
				predicate.Predicand = lhs
				predicate.Pattern = rhs
				expr = predicate
			case analysis.IsSimilar, analysis.NotSimilar:
				predicate := SQL.SimilarPredicate{}
				predicate.Not = (pred == analysis.NotSimilar)
				predicate.Predicand = lhs
				predicate.Pattern = rhs
				expr = predicate
			case analysis.IsDistinct, analysis.NotDistinct:
				predicate := SQL.DistinctPredicate{}
				predicate.Not = (pred == analysis.NotDistinct)
				predicate.LPredicand = lhs
				predicate.RPredicand = rhs
				expr = predicate
			case analysis.IsMatch, analysis.IsMatchi, analysis.NotMatch, analysis.NotMatchi:
				predicate := SQL.RegexPredicate{}
				predicate.Op = sqlREGEXOP[pred]
				predicate.Predicand = lhs
				predicate.Pattern = rhs
				expr = predicate
			case analysis.IsIn, analysis.NotIn:
				sx := GO.SelectorExpr{X: sx, Sel: GO.Ident{fieldName}}
				g.inputSliceArgs = append(g.inputSliceArgs, sx)
				g.paramNum -= 1 // ordinal param won't be used directly

				num := strconv.Itoa(len(g.inputSliceArgs))
				arg1 := GO.Ident{"len" + num}
				arg2 := GO.Ident{"pos" + num}

				call := GO.CallExpr{Fun: GO.QualifiedIdent{"gosql", "InValueList"}}
				call.Args = GO.ArgsList{List: GO.ExprList{arg1, arg2}}

				predicate := SQL.InPredicate{}
				predicate.Not = (pred == analysis.NotIn)
				predicate.Predicand = lhs
				predicate.ValueList = SQL.HostValue{GO.RawStringInsertExpr{call}}
				expr = predicate
			case analysis.IsTrue, analysis.NotTrue, analysis.IsFalse, analysis.NotFalse, analysis.IsUnknown, analysis.NotUnknown:
				predicate := SQL.TruthPredicate{}
				predicate.Not = (pred == analysis.NotTrue || pred == analysis.NotFalse || pred == analysis.NotUnknown)
				predicate.Truth = sqlTRUTH[pred]
				predicate.Predicand = lhs
				expr = predicate
			case analysis.IsNull, analysis.NotNull:
				predicate := SQL.NullPredicate{}
				predicate.Not = (pred == analysis.NotNull)
				predicate.Predicand = lhs
				expr = predicate
			default:
				// no predicate, assume lhs is by itself a boolean value expression
				if predicate, ok := lhs.(SQL.BoolValueExpr); ok {
					expr = predicate
				}
			}
		}

		if i == 0 { // initial?
			list.Initial = expr
		} else {
			if boolean == analysis.BoolAnd {
				list.Items = append(list.Items, SQL.AND{Operand: expr})
			} else if boolean == analysis.BoolOr {
				list.Items = append(list.Items, SQL.OR{Operand: expr})
			}
		}
	}

	if count > 2 {
		list.ListStyle = true
	}

	list.Parenthesized = parenthesized
	return list, count
}

// makeSQLBetweenPredicate
func makeSQLBetweenPredicate(g *generator, cond *postgres.BetweenConditional) SQL.BetweenPredicate {
	predicate := SQL.BetweenPredicate{}
	predicate.Predicand = makeColRef(cond.ColIdent)

	switch lower := cond.LowerBound.(type) {
	case *postgres.ColumnConditional:
		predicate.LowEnd = makeColRef(lower.RHSColIdent)
	case *postgres.FieldConditional:
		predicate.LowEnd = makeParamSpec(g, lower)
	}

	switch upper := cond.UpperBound.(type) {
	case *postgres.ColumnConditional:
		predicate.HighEnd = makeColRef(upper.RHSColIdent)
	case *postgres.FieldConditional:
		predicate.HighEnd = makeParamSpec(g, upper)
	}

	return predicate
}

func buildQueryStringDecl(g *generator, qs *analysis.QueryStruct) {
	spec := GO.ValueSpec{}
	spec.Names = GO.Ident{"queryString"}
	spec.Values = GO.RawStringNode{N: g.sqlMainNode}
	spec.Comment = GO.LineComment{" `"}
	if canDeclareConst(g, qs) {
		g.queryStringDecl = GO.ConstDecl{Spec: spec}
	} else {
		g.queryStringDecl = GO.VarDecl{Spec: spec}
	}
}

// buildQueryStringForSliceInsertOrUpdate
func buildQueryStringForSliceInsertOrUpdate(g *generator, qs *analysis.QueryStruct) {
	var (
		stmtList       = GO.StmtList{GO.DeclStmt{g.queryStringDecl}, GO.NL{}}
		relField       = GO.QualifiedIdent{"q", qs.Rel.FieldName}
		fieldCount     = GO.IntLit(len(g.inputArgs))
		queryStringVar = GO.Ident{"queryString"}
		paramsVar      = GO.Ident{"params"}
		ifaceSliceType = GO.Ident{"[]interface{}"}
		ordinalParams  = GO.QualifiedIdent{"gosql", "OrdinalParameters"}
		forLoop        = GO.ForStmt{}
	)

	if len(g.inputArgs) > 0 {
		// produce:
		//	params := make([]interface{}, len(<relField>)*<fieldCount>)
		binExpr := GO.BinaryExpr{}
		binExpr.Op = GO.BinaryMul
		binExpr.X = GO.CallLenExpr{relField}
		binExpr.Y = fieldCount

		makeCall := GO.CallMakeExpr{}
		makeCall.Type = ifaceSliceType
		makeCall.Size = binExpr

		assign := GO.AssignStmt{Token: GO.AssignDefine}
		assign.Lhs = paramsVar
		assign.Rhs = makeCall
		stmtList = append(stmtList, assign)

		// produce:
		//	for i, v := range <relField> {
		rangeClause := GO.ForRangeClause{}
		rangeClause.Key = GO.Ident{"i"}
		rangeClause.Value = GO.Ident{"v"}
		rangeClause.X = relField
		rangeClause.Define = true
		forLoop.Clause = rangeClause

		// produce:
		//	pos := i * <fieldCount>
		assign = GO.AssignStmt{Token: GO.AssignDefine}
		assign.Lhs = GO.Ident{"pos"}
		assign.Rhs = GO.BinaryExpr{Op: GO.BinaryMul, X: GO.Ident{"i"}, Y: fieldCount}
		forLoop.Body = GO.BlockStmt{List: []GO.StmtNode{assign, GO.NL{}}}

		// produce:
		//	params[pos+<i>] = <arg>
		assignList := make([]GO.StmtNode, len(g.inputArgs))
		for i, arg := range g.inputArgs {
			binExpr := GO.BinaryExpr{Op: GO.BinaryAdd}
			binExpr.X = GO.Ident{"pos"}
			binExpr.Y = GO.IntLit(i)

			assign := GO.AssignStmt{Token: GO.Assign}
			assign.Lhs = GO.IndexExpr{X: paramsVar, Index: binExpr}
			assign.Rhs = arg
			assignList[i] = assign
		}
		forLoop.Body.List = append(forLoop.Body.List, assignList...)
		forLoop.Body.List = append(forLoop.Body.List, GO.NL{})
	} else {
		// produce:
		//	for _, _ = range <relField> {
		rangeClause := GO.ForRangeClause{}
		rangeClause.Key = GO.Ident{"_"}
		rangeClause.Value = GO.Ident{"_"}
		rangeClause.X = relField
		forLoop.Clause = rangeClause
	}

	var (
		defaultCount      = 0
		valueCount        = len(g.inputVals) + len(g.inputValsPKeys)
		strConcatExprList = make([]GO.ExprNode, valueCount+1) // +1 for the final `),`
	)

	inputVals := append(g.inputVals, g.inputValsPKeys...)
	for i, val := range inputVals {
		sep := `, `
		if i == 0 {
			sep = `(`
		}

		if val == SQL.DEFAULT {
			defaultCount += 1
			strConcatExprList[i] = GO.RawStringLit(sep + `DEFAULT`)
		} else {
			// produce:
			//	`, ` + gosql.OrdinalParameters[pos+<i - defaultCount>] +
			binExpr := GO.BinaryExpr{Op: GO.BinaryAdd}
			binExpr.X = GO.Ident{"pos"}
			binExpr.Y = GO.IntLit(i - defaultCount)

			concatExpr := GO.BinaryExpr{Op: GO.BinaryAdd}
			concatExpr.X = GO.RawStringLit(sep)
			concatExpr.Y = GO.IndexExpr{X: ordinalParams, Index: binExpr}

			if _, ok := val.(SQL.NULLIF); ok {
				concatExpr.X = GO.RawStringLit(sep + `NULLIF(`)
				concatExpr = GO.BinaryExpr{X: concatExpr, Op: GO.BinaryAdd}
				concatExpr.Y = GO.RawStringLit(`)`)
			} else if cast, ok := val.(SQL.CastExpr); ok {
				if _, ok := cast.Expr.(SQL.NULLIF); ok {
					concatExpr.X = GO.RawStringLit(sep + `NULLIF(`)
					concatExpr = GO.BinaryExpr{X: concatExpr, Op: GO.BinaryAdd}
					concatExpr.Y = GO.RawStringLit(`)::` + cast.Type)
				}
			}

			strConcatExprList[i] = concatExpr

		}
	}

	strConcatExprList[len(strConcatExprList)-1] = GO.RawStringLit(`),`)

	assign := GO.AssignStmt{Token: GO.AssignAdd}
	assign.Lhs = queryStringVar
	assign.Rhs = GO.MultiLineExpr{Op: GO.BinaryAdd, Exprs: strConcatExprList}
	forLoop.Body.List = append(forLoop.Body.List, assign)
	stmtList = append(stmtList, forLoop)

	// produce:
	//	queryString = queryString[:len(queryString)-1]
	binExpr := GO.BinaryExpr{Op: GO.BinarySub}
	binExpr.X = GO.CallLenExpr{queryStringVar}
	binExpr.Y = GO.IntLit(1)

	assign = GO.AssignStmt{Token: GO.Assign}
	assign.Lhs = queryStringVar
	assign.Rhs = GO.SliceExpr{X: queryStringVar, High: binExpr}
	stmtList = append(stmtList, GO.NL{}, assign)

	if g.sqlTailNode != nil {
		assign := GO.AssignStmt{Token: GO.AssignAdd}
		assign.Lhs = queryStringVar
		assign.Rhs = GO.RawStringNode{Prefix: " ", N: g.sqlTailNode, Comment: &GO.LineComment{" `"}}
		stmtList = append(stmtList, assign)
	}

	g.queryStringStmt = stmtList
}

// buildQueryStringForSliceArgs
func buildQueryStringForSliceArgs(g *generator, qs *analysis.QueryStruct) {
	// produce:
	//	var (
	// 	     nstatic = <paramNum>
	// 	     ...
	// 	)
	varDecl := GO.VarDecl{}

	nstaticVar := GO.ValueSpec{}
	nstaticVar.Names = GO.Ident{"nstatic"}
	nstaticVar.Values = GO.IntLit(g.paramNum)
	nstaticVar.Comment = GO.LineComment{" number of static parameters"}

	specList := GO.ValueSpecList{nstaticVar}
	for i, arg := range g.inputSliceArgs {
		num := strconv.Itoa(i + 1)

		lenVar := GO.ValueSpec{}
		lenVar.Names = GO.Ident{"len" + num}
		lenVar.Values = GO.CallLenExpr{arg}
		lenVar.Comment = GO.LineComment{" length of slice #" + num + " to be unnested"}

		posVar := GO.ValueSpec{}
		posVar.Names = GO.Ident{"pos" + num}
		if i == 0 {
			// the first position is set to the value of nstatic
			posVar.Values = GO.Ident{"nstatic"}
		} else {
			// the rest of the positions are calculated from
			// adding the previous length to the previous position
			prev := strconv.Itoa(i)
			prevLen := GO.Ident{"len" + prev}
			prevPost := GO.Ident{"pos" + prev}
			posVar.Values = GO.BinaryExpr{Op: GO.BinaryAdd, X: prevPost, Y: prevLen}
		}
		posVar.Comment = GO.LineComment{" starting position of slice #" + num + " parameters"}

		specList = append(specList, lenVar, posVar)
	}
	varDecl.Spec = specList

	var (
		stmtList       = GO.StmtList{GO.DeclStmt{varDecl}, GO.NL{}, GO.DeclStmt{g.queryStringDecl}, GO.NL{}}
		paramsVar      = GO.Ident{"params"}
		ifaceSliceType = GO.Ident{"[]interface{}"}
	)

	// produce:
	//	params := make([]interface{}, nstatic + len1 [ + len<i> ])
	binExpr := GO.BinaryExpr{Op: GO.BinaryAdd}
	binExpr.X = GO.Ident{"nstatic"}
	binExpr.Y = GO.Ident{"len1"}
	for i := 1; i < len(g.inputSliceArgs); i++ {
		y := GO.Ident{"len" + strconv.Itoa(i+1)}
		binExpr = GO.BinaryExpr{Op: GO.BinaryAdd, X: binExpr, Y: y}
	}

	makeCall := GO.CallMakeExpr{}
	makeCall.Type = ifaceSliceType
	makeCall.Size = binExpr

	assign := GO.AssignStmt{Token: GO.AssignDefine}
	assign.Lhs = paramsVar
	assign.Rhs = makeCall
	stmtList = append(stmtList, assign)

	// directly assign non-slice params
	for i, arg := range g.inputArgs {
		assign := GO.AssignStmt{Token: GO.Assign}
		assign.Lhs = GO.IndexExpr{X: paramsVar, Index: GO.IntLit(i)}
		assign.Rhs = arg
		stmtList = append(stmtList, assign)
	}

	iVar := GO.Ident{"i"}
	for i, arg := range g.inputSliceArgs {
		lenVar := GO.Ident{"len" + strconv.Itoa(i+1)}
		posVar := GO.Ident{"pos" + strconv.Itoa(i+1)}

		forClause := GO.ForClause{}
		forClause.Init = GO.AssignStmt{Token: GO.AssignDefine, Lhs: iVar, Rhs: GO.IntLit(0)}
		forClause.Cond = GO.BinaryExpr{X: iVar, Op: GO.BinaryLss, Y: lenVar}
		forClause.Post = GO.IncDecStmt{X: iVar, Token: GO.IncDecIncrement}
		forLoop := GO.ForStmt{Clause: forClause}

		binExpr := GO.BinaryExpr{Op: GO.BinaryAdd}
		binExpr.X = posVar
		binExpr.Y = iVar

		assign := GO.AssignStmt{Token: GO.Assign}
		assign.Lhs = GO.IndexExpr{X: paramsVar, Index: binExpr}
		assign.Rhs = GO.IndexExpr{X: arg, Index: iVar}

		forLoop.Body = GO.BlockStmt{List: []GO.StmtNode{assign}}
		stmtList = append(stmtList, forLoop)
	}

	stmtList = append(stmtList, GO.NL{})
	g.queryStringStmt = stmtList
}

// buildQueryStringForFilter
func buildQueryStringForFilter(g *generator, qs *analysis.QueryStruct) {
	var (
		stmtList        = GO.StmtList{GO.DeclStmt{g.queryStringDecl}, GO.NL{}}
		queryStringVar  = GO.Ident{"queryString"}
		filterStringVar = GO.Ident{"filterString"}
		paramsVar       = GO.Ident{"params"}
		filterField     = GO.QualifiedIdent{"q", qs.Filter.Name}
	)

	// produce:
	//	filterString, params := q.Filter.ToSQL(N)
	callExpr := GO.CallExpr{}
	callExpr.Fun = GO.SelectorExpr{X: filterField, Sel: GO.Ident{"ToSQL"}}
	callExpr.Args = GO.ArgsList{List: GO.IntLit(len(g.inputArgs))}

	assign := GO.AssignStmt{Token: GO.AssignDefine}
	assign.Lhs = GO.ExprList{filterStringVar, paramsVar}
	assign.Rhs = callExpr
	stmtList = append(stmtList, assign)

	rhsExpr := GO.ExprNode(filterStringVar)
	if g.closeFilter {
		// produce:
		//	filterString + `)`
		binAdd := GO.BinaryExpr{Op: GO.BinaryAdd}
		binAdd.X = filterStringVar
		binAdd.Y = GO.RawStringLit(`)`)
		rhsExpr = binAdd
	}

	assign2 := GO.AssignStmt{Token: GO.AssignAdd}
	assign2.Lhs = queryStringVar
	assign2.Rhs = rhsExpr
	stmtList = append(stmtList, assign2)

	if g.sqlTailNode != nil {
		// produce:
		//	queryString += " " + <sqlTailNode> // `
		assign := GO.AssignStmt{Token: GO.AssignAdd}
		assign.Lhs = queryStringVar
		assign.Rhs = GO.RawStringNode{Prefix: " ", N: g.sqlTailNode, Comment: &GO.LineComment{" `"}}
		stmtList = append(stmtList, assign)
	}

	stmtList = append(stmtList, GO.NL{})
	g.queryStringStmt = stmtList
}

func buildQueryFilterParams(g *generator, qs *analysis.QueryStruct) {
	if qs.Filter == nil || qs.Kind != analysis.QueryKindUpdate {
		g.queryFilterParams = GO.NoOp{}
		return
	}

	var (
		stmtList       = GO.StmtList{}
		paramsVar      = GO.Ident{"params"}
		ifaceSliceType = GO.Ident{"[]interface{}"}
	)

	// produce:
	//	params = append([]interface{}{ ... }, params...)
	argsList := GO.SliceLit{Type: ifaceSliceType, Elems: GO.ExprList(g.inputArgs)}

	appendCall := GO.CallExpr{Fun: GO.Ident{"append"}}
	appendCall.Args = GO.ArgsList{List: GO.ExprList{argsList, paramsVar}, Ellipsis: true}

	assign := GO.AssignStmt{Token: GO.Assign}
	assign.Lhs = paramsVar
	assign.Rhs = appendCall
	stmtList = append(stmtList, assign, GO.NL{})

	g.queryFilterParams = stmtList
}

// buildQueryCallExec
func buildQueryCallExec(g *generator, qs *analysis.QueryStruct) {

	var (
		resVar   = GO.Ident{"_"}
		errVar   = GO.Ident{"err"}
		execFunc = GO.QualifiedIdent{"c", "Exec"}
		inArgs   = makeInputArgsList(g, qs)
	)
	if qs.RowsAffected != nil {
		resVar = GO.Ident{"res"}
	}
	if qs.Context != nil {
		execFunc = GO.QualifiedIdent{"c", "ExecContext"}
	}

	assign := GO.AssignStmt{Token: GO.AssignDefine}
	assign.Lhs = GO.ExprList{resVar, errVar}
	assign.Rhs = GO.CallExpr{Fun: execFunc, Args: inArgs}
	g.queryCallStmt = assign
}

// buildQueryCallQueryRow
func buildQueryCallQueryRow(g *generator, qs *analysis.QueryStruct) {
	var (
		queryRowFunc = GO.QualifiedIdent{"c", "QueryRow"}
		inArgs       = makeInputArgsList(g, qs)
	)
	if qs.Context != nil {
		queryRowFunc = GO.QualifiedIdent{"c", "QueryRowContext"}
	}

	assign := GO.AssignStmt{Token: GO.AssignDefine}
	assign.Lhs = GO.Ident{"row"}
	assign.Rhs = GO.CallExpr{Fun: queryRowFunc, Args: inArgs}
	g.queryCallStmt = assign
}

// buildQueryCallQuery
func buildQueryCallQuery(g *generator, qs *analysis.QueryStruct) {
	var (
		nilVal        = GO.Ident{"nil"}
		errVar        = GO.Ident{"err"}
		rowsVar       = GO.Ident{"rows"}
		queryFunc     = GO.QualifiedIdent{"c", "Query"}
		rowsCloseCall = GO.CallExpr{Fun: GO.QualifiedIdent{"rows", "Close"}}
		stmtList      = GO.StmtList{}
		inArgs        = makeInputArgsList(g, qs)
	)
	if qs.Context != nil {
		queryFunc = GO.QualifiedIdent{"c", "QueryContext"}
	}

	// query call, err check, defer statement
	assign := GO.AssignStmt{Token: GO.AssignDefine}
	assign.Lhs = GO.ExprList{rowsVar, errVar}
	assign.Rhs = GO.CallExpr{Fun: queryFunc, Args: inArgs}

	iferr := GO.IfStmt{}
	iferr.Cond = GO.BinaryExpr{Op: GO.BinaryNeq, X: errVar, Y: nilVal}
	iferr.Body = GO.BlockStmt{List: []GO.StmtNode{makeErrorReturnStmt(g, qs, errVar)}}

	deferStmt := GO.DeferStmt{}
	deferStmt.Call = rowsCloseCall

	stmtList = append(stmtList, assign, iferr, deferStmt, GO.NL{})
	g.queryCallStmt = stmtList
}

// buildQueryResultRowsAffected
func buildQueryResultRowsAffected(g *generator, qs *analysis.QueryStruct) {
	var (
		nilVal       = GO.Ident{"nil"}
		errVar       = GO.Ident{"err"}
		i64Var       = GO.Ident{"i64"}
		rowsAffected = GO.QualifiedIdent{"res", "RowsAffected"}
		stmtList     = GO.StmtList{}

		iferr = makeErrorIfStmt(g, qs)
	)

	// produce:
	//      ...
	//	if err != nil {
	//		return err
	//	}
	//	i64, err := res.RowsAffected()
	//	if err != nil {
	//		return err
	//	}
	//      ...
	assign := GO.AssignStmt{Token: GO.AssignDefine}
	assign.Lhs = GO.ExprList{i64Var, errVar}
	assign.Rhs = GO.CallExpr{Fun: rowsAffected}
	stmtList = append(stmtList, iferr, assign, iferr)

	// produce:
	//	...
	//
	//	q.<RowsAffected> = <i64 | T(i64)>
	//      return nil
	rhsExpr := GO.ExprNode(i64Var)
	if kind := qs.RowsAffected.TypeKind; kind != analysis.TypeKindInt64 {
		// type conversion
		callExpr := GO.CallExpr{}
		callExpr.Fun = GO.Ident{kind.BasicString()}
		callExpr.Args = GO.ArgsList{List: rhsExpr}
		rhsExpr = callExpr
	}
	assign = GO.AssignStmt{Token: GO.Assign}
	assign.Lhs = GO.QualifiedIdent{"q", qs.RowsAffected.Name}
	assign.Rhs = rhsExpr
	stmtList = append(stmtList, GO.NL{}, assign, GO.ReturnStmt{nilVal})

	g.queryResultStmt = stmtList
}

// buildQueryResultRowScan
func buildQueryResultRowScan(g *generator, qs *analysis.QueryStruct) {
	var (
		rowScan  = GO.QualifiedIdent{"row", "Scan"}
		stmtList = GO.StmtList{}

		iferr   = makeErrorIfStmt(g, qs)
		outArgs = makeOutputArgsList(g, qs)
	)

	// produce:
	//	v := new(T)
	//	...
	stmtList = append(stmtList, g.outputInit...)

	// produce:
	//	row.Scan(<outArgs>)
	rowScanCall := GO.CallExpr{Fun: rowScan, Args: outArgs}
	if !g.outputIsAfterScanner && qs.HasNoErrorInfoHandler() {
		// produce:
		//	return row.Scan(<outArgs>)
		retstmt := makeErrorReturnStmt(g, qs, rowScanCall)
		g.queryResultStmt = append(stmtList, retstmt)
		return
	}

	// produce:
	//	...
	//	err := row.Scan(<outArgs>)
	//	if err != nil {
	//		return err
	//	}
	assign := GO.AssignStmt{Token: GO.AssignDefine}
	assign.Lhs = GO.Ident{"err"}
	assign.Rhs = rowScanCall
	stmtList = append(stmtList, assign, iferr)

	if g.outputIsAfterScanner {
		// produce:
		//
		//	<outputRoot>.AfterScan()
		selExpr := GO.SelectorExpr{X: g.outputVar, Sel: GO.Ident{"AfterScan"}}
		callExpr := GO.ExprStmt{GO.CallExpr{Fun: selExpr}}
		stmtList = append(stmtList, GO.NL{}, callExpr)
	}

	// produce:
	//	return nil
	stmtList = append(stmtList, GO.ReturnStmt{GO.Ident{"nil"}})
	g.queryResultStmt = stmtList
}

// buildQueryResultRowsScan
func buildQueryResultRowsScan(g *generator, qs *analysis.QueryStruct) {
	var (
		errVar       = GO.Ident{"err"}
		nilVal       = GO.Ident{"nil"}
		rowsScanFunc = GO.QualifiedIdent{"rows", "Scan"}
		rowsErr      = GO.CallExpr{Fun: GO.QualifiedIdent{"rows", "Err"}}
		rowsNext     = GO.CallExpr{Fun: GO.QualifiedIdent{"rows", "Next"}}
		forStmt      = GO.ForStmt{Clause: GO.ForCondition{rowsNext}}
		stmtList     = GO.StmtList{}
		outArgs      = makeOutputArgsList(g, qs)
		iferr        = makeErrorIfStmt(g, qs)
	)

	// produce:
	//	i := 0
	if g.outputToInput {
		assign := GO.AssignStmt{Token: GO.AssignDefine}
		assign.Lhs = GO.Ident{"i"}
		assign.Rhs = GO.IntLit(0)
		stmtList = append(stmtList, assign)
	}

	////////////////////////////////////////////////////////////////////////
	// For Loop Body - start

	// produce:
	//	v := new(T)
	//      v.F = new(U)
	//      ...
	forStmt.Body.List = append(forStmt.Body.List, g.outputInit...)

	// produce:
	//	err := rows.Scan(<outArgs>)
	//      if err != nil {
	//		return err
	//      }
	//
	assign := GO.AssignStmt{Token: GO.AssignDefine}
	assign.Lhs = errVar
	assign.Rhs = GO.CallExpr{Fun: rowsScanFunc, Args: outArgs}
	forStmt.Body.List = append(forStmt.Body.List, assign, iferr, GO.NL{})

	if g.outputIsAfterScanner {
		// produce:
		//	<outputVar>.AfterScan()
		selExpr := GO.SelectorExpr{X: g.outputVar, Sel: GO.Ident{"AfterScan"}}
		callExpr := GO.ExprStmt{GO.CallExpr{Fun: selExpr}}
		forStmt.Body.List = append(forStmt.Body.List, callExpr)
	}

	if g.outputIsIter {
		// produce:
		//	if err := <outputRoot>.<iterMethod>(v); err != nil {
		//		return err
		//	}
		iterCall := GO.CallExpr{}
		iterCall.Fun = g.outputRoot
		iterCall.Args = GO.ArgsList{List: GO.Ident{"v"}}
		if mth := g.outputIterMethod; len(mth) > 0 {
			iterCall.Fun = GO.SelectorExpr{X: g.outputRoot, Sel: GO.Ident{mth}}
		}

		assign := GO.AssignStmt{Token: GO.AssignDefine}
		assign.Lhs = errVar
		assign.Rhs = iterCall

		iferr := GO.IfStmt{}
		iferr.Init = assign
		iferr.Cond = GO.BinaryExpr{Op: GO.BinaryNeq, X: errVar, Y: nilVal}
		iferr.Body = GO.BlockStmt{List: []GO.StmtNode{makeErrorReturnStmt(g, qs, errVar)}}
		forStmt.Body.List = append(forStmt.Body.List, iferr)
	} else if g.outputToInput {
		// produce:
		//	i += 1
		assign := GO.AssignStmt{Token: GO.AssignAdd}
		assign.Lhs = GO.Ident{"i"}
		assign.Rhs = GO.IntLit(1)
		forStmt.Body.List = append(forStmt.Body.List, assign)
	} else {
		// produce:
		//	<outputRoot> = append(<outputRoot>, v)
		appendCall := GO.CallExpr{Fun: GO.Ident{"append"}}
		appendCall.Args = GO.ArgsList{List: GO.ExprList{g.outputRoot, GO.Ident{"v"}}}

		assign := GO.AssignStmt{Token: GO.Assign}
		assign.Lhs = g.outputRoot
		assign.Rhs = appendCall
		forStmt.Body.List = append(forStmt.Body.List, assign)
	}

	// For Loop Body - end
	////////////////////////////////////////////////////////////////////////

	returnStmt := makeErrorReturnStmt(g, qs, rowsErr)
	stmtList = append(stmtList, forStmt, returnStmt)
	g.queryResultStmt = stmtList
}

////////////////////////////////////////////////////////////////////////////////
// Helpers
//

func inputPKeys(t *postgres.TargetInfo) (out []*postgres.FieldWrite) {
	for i := 0; i < len(t.PKeys); i++ {
		elide := false
		for j := 0; j < len(t.Writes); j++ {
			if t.Writes[j].Field == t.PKeys[i].Field {
				elide = true
			}
		}
		if !elide {
			out = append(out, t.PKeys[i])
		}
	}
	return out
}

// addImport
func addImport(g *generator, path, name, local string) {
	// check that the package path hasn't yet been added to the imports
	for _, spec := range g.imports.Specs {
		if string(spec.Path) == path {
			return
		}
	}

	// if the local name is the same as the package name set it to empty
	if local == name {
		local = ""
	}

	spec := GO.ImportSpec{Path: GO.StringLit(path), Name: GO.Ident{local}}
	g.imports.Specs = append(g.imports.Specs, spec)
}

func sortImports(imports *GO.ImportDecl) {
	var specs1, specs2, specs3 []GO.ImportSpec
	for _, s := range imports.Specs {
		if strings.HasPrefix(string(s.Path), gosqlPkgPath) {
			specs3 = append(specs3, s)
		} else if i := strings.IndexByte(string(s.Path), '.'); i >= 0 {
			specs2 = append(specs2, s)
		} else {
			specs1 = append(specs1, s)
		}
	}

	// imports.Specs = append(imports.Specs, GO.ImportSpec{Doc: GO.NL{}, Path: gosqlPkgPath})

	var specs []GO.ImportSpec
	if len(specs1) > 0 {
		specs = append(specs, specs1...)
	}
	if len(specs2) > 0 {
		specs2[0].Doc = GO.NL{}
		specs = append(specs, specs2...)
	}
	if len(specs3) > 0 {
		specs3[0].Doc = GO.NL{}
		specs = append(specs, specs3...)
	}
	imports.Specs = specs
}

// makeErrorReturnStmt
func makeErrorReturnStmt(g *generator, qs *analysis.QueryStruct, errExpr GO.ExprNode) GO.StmtNode {
	if qs.ErrorHandler == nil {
		return GO.ReturnStmt{errExpr}
	}

	fieldSelector := GO.QualifiedIdent{"q", qs.ErrorHandler.Name}
	if qs.ErrorHandler.IsInfo {
		var (
			errVar         = GO.Ident{"err"}
			nilVal         = GO.Ident{"nil"}
			queryStringVar = GO.Ident{"queryString"}
			errorInfoType  = GO.QualifiedIdent{"gosql", "ErrorInfo"}
		)

		// produce:
		//	return <fieldSelector>.HandleErrorInfo(&gosql.ErrorInfo{ ... })
		literal := GO.StructLit{Type: errorInfoType, Compact: true}
		literal.Elems = []GO.FieldElement{
			{"Error", errVar},
			{"QueryString", queryStringVar},
			{"QueryKind", GO.StringLit(qs.Kind.String())},
			{"QueryName", GO.StringLit(qs.TypeName)},
			{"QueryValue", GO.Ident{"q"}},
		}

		callExpr := GO.CallExpr{}
		callExpr.Fun = GO.SelectorExpr{X: fieldSelector, Sel: GO.Ident{"HandleErrorInfo"}}
		callExpr.Args = GO.ArgsList{List: GO.UnaryExpr{Op: GO.UnaryAmp, X: literal}}
		if errExpr == errVar {
			return GO.ReturnStmt{callExpr}
		}

		// produce:
		//	if err := <errExpr>; err != nil {
		//		return <fieldSelector>.HandleErrorInfo(&gosql.ErrorInfo{ ... })
		//	}
		//	return nil
		assign := GO.AssignStmt{Token: GO.AssignDefine}
		assign.Lhs = errVar
		assign.Rhs = errExpr

		iferr := GO.IfStmt{}
		iferr.Init = assign
		iferr.Cond = GO.BinaryExpr{Op: GO.BinaryNeq, X: errVar, Y: nilVal}
		iferr.Body = GO.BlockStmt{List: []GO.StmtNode{GO.ReturnStmt{callExpr}}}
		return GO.StmtList{iferr, GO.ReturnStmt{nilVal}}
	}

	// produce:
	//	return <fieldSelector>.HandleError(<errExpr>)
	callExpr := GO.CallExpr{}
	callExpr.Fun = GO.SelectorExpr{X: fieldSelector, Sel: GO.Ident{"HandleError"}}
	callExpr.Args = GO.ArgsList{List: errExpr}
	return GO.ReturnStmt{callExpr}
}

// makeInputArgsList
func makeInputArgsList(g *generator, qs *analysis.QueryStruct) GO.ArgsList {
	argsList := GO.ArgsList{List: GO.Ident{"queryString"}}
	if qs.Context != nil {
		argsList = GO.ArgsList{List: GO.ExprList{
			GO.QualifiedIdent{"q", qs.Context.Name},
			GO.Ident{"queryString"},
		}}
	}

	if len(g.inputSliceArgs) > 0 || qs.Filter != nil || (qs.IsInsertOrUpdateSlice() && len(g.inputArgs) > 0) {
		argsList.AddExprs(GO.Ident{"params"})
		argsList.Ellipsis = true
		return argsList
	}

	argsList.AddExprs(g.inputArgs...)
	if argsList.Len() > 3 {
		argsList.OnePerLine = 2
	}
	return argsList
}

// makeOutputArgsList
func makeOutputArgsList(g *generator, qs *analysis.QueryStruct) GO.ArgsList {
	argsList := GO.ArgsList{List: GO.ExprList(g.outputArgs)}
	if len(g.outputArgs) > 2 {
		argsList.OnePerLine = 1
	}
	return argsList
}

// makeErrorIfStmt
func makeErrorIfStmt(g *generator, qs *analysis.QueryStruct) GO.IfStmt {
	var (
		errVar = GO.Ident{"err"}
		nilVal = GO.Ident{"nil"}
	)

	stmt := GO.IfStmt{}
	stmt.Cond = GO.BinaryExpr{Op: GO.BinaryNeq, X: errVar, Y: nilVal}
	stmt.Body = GO.BlockStmt{List: []GO.StmtNode{makeErrorReturnStmt(g, qs, errVar)}}
	return stmt
}

// makeParamSpec
func makeParamSpec(g *generator, ptr analysis.FieldPtr) SQL.OrdinalParameterSpec {
	if ptr != nil {
		if g.paramSet == nil {
			g.paramSet = make(map[analysis.FieldPtr]int)
		}

		if num, ok := g.paramSet[ptr]; ok {
			return SQL.OrdinalParameterSpec{num}
		}
		g.paramNum += 1
		g.paramSet[ptr] = g.paramNum
		return SQL.OrdinalParameterSpec{g.paramNum}
	}

	g.paramNum += 1
	return SQL.OrdinalParameterSpec{g.paramNum}
}

// makeRelTypeNode
func makeRelTypeNode(reltyp analysis.RelType) GO.TypeNode {
	if reltyp.Base.IsImported {
		return GO.QualifiedIdent{reltyp.Base.PkgName, reltyp.Base.Name}
	}
	return GO.Ident{reltyp.Base.Name}
}

// makeSelTypeNode
func makeSelTypeNode(node *analysis.FieldSelectorNode) GO.TypeNode {
	if node.IsImported {
		return GO.QualifiedIdent{node.TypePkgName, node.TypeName}
	}
	return GO.Ident{node.TypeName}
}

// makeColRef
func makeColRef(id analysis.ColIdent) SQL.ColumnReference {
	return SQL.ColumnReference{
		Qual: id.Qualifier,
		Name: SQL.Name(id.Name),
	}
}

// makeRelIdent
func makeRelIdent(id analysis.RelIdent) SQL.Ident {
	return SQL.Ident{
		Name:  SQL.Name(id.Name),
		Qual:  id.Qualifier,
		Alias: id.Alias,
	}
}

////////////////////////////////////////////////////////////////////////////////
// Predicate Functions
//

// isSliceUpdate reports whether or not the given QueryStruct represents
// an update with a slice type for its relation field.
func isSliceUpdate(qs *analysis.QueryStruct) bool {
	return qs.Kind == analysis.QueryKindUpdate && qs.Rel.Type.IsSlice
}

// canUseDefault reports whether or not the SQL's DEFAULT marker should be
// used to write a column.
func canUseDefault(qs *analysis.QueryStruct, f *analysis.FieldInfo) bool {
	return f.UseDefault || (qs.Default != nil && qs.Default.Contains(f.ColIdent))
}

// canSkipRelInit reports whether or not the GO output fields should be, if
// they are pointers, initialized.
func canSkipRelInit(qs *analysis.QueryStruct) bool {
	return qs.IsInsertOrUpdate() && qs.Result == nil
}

// canDeclareConst reports whether or not the queryString value can be declared as a const.
func canDeclareConst(g *generator, qs *analysis.QueryStruct) bool {
	return qs.Filter == nil && len(g.inputSliceArgs) == 0 && !qs.IsInsertOrUpdateSlice()
}

////////////////////////////////////////////////////////////////////////////////
// Filter Key Formatter Functions
//

// makeFilterKeyFormatter
func makeFilterKeyFormatter(conf Config) (fn func(*postgres.FieldFilter) string) {
	if len(conf.FilterColumnKeyTag) > 0 {
		if !conf.FilterColumnKeyBase {
			return func(ff *postgres.FieldFilter) string {
				return fmtFieldTagJoinedKey(ff, conf.FilterColumnKeyTag, conf.FilterColumnKeySeparator)
			}
		}
		return func(ff *postgres.FieldFilter) string {
			return fmtFieldTagBaseKey(ff, conf.FilterColumnKeyTag)
		}
	}

	if !conf.FilterColumnKeyBase {
		return func(ff *postgres.FieldFilter) string {
			return fmtFieldNameJoinedKey(ff, conf.FilterColumnKeySeparator)
		}
	}
	return fmtFieldNameBaseKey
}

// fmtFieldNameBaseKey
func fmtFieldNameBaseKey(ff *postgres.FieldFilter) string {
	return ff.Field.Name
}

// fmtFieldNameJoinedKey
func fmtFieldNameJoinedKey(ff *postgres.FieldFilter, sep string) (key string) {
	for _, node := range ff.Field.Selector {
		key += node.Name + sep
	}
	return key + ff.Field.Name
}

// fmtFieldTagBaseKey
func fmtFieldTagBaseKey(ff *postgres.FieldFilter, tag string) string {
	return ff.Field.Tag.First(tag)
}

// fmtFieldTagJoinedKey
func fmtFieldTagJoinedKey(ff *postgres.FieldFilter, tag, sep string) (key string) {
	for _, node := range ff.Field.Selector {
		key += node.Tag.First(tag) + sep
	}
	return key + ff.Field.Tag.First(tag)
}

////////////////////////////////////////////////////////////////////////////////
// Column Identifier Formatter Functions
//

// makeColIdentFormatter
func makeColIdentFormatter(conf Config) (fn func(analysis.ColIdent) string) {
	if conf.QuoteIdentifiers {
		return fmtColIdentQuoted
	}
	return fmtColIdent
}

// fmtColIdent returns the string representation of the column identifier.
func fmtColIdent(id analysis.ColIdent) string {
	if len(id.Qualifier) > 0 {
		return id.Qualifier + "." + id.Name
	}
	return id.Name
}

// fmtColIdentQuoted returns the string representation of the column identifier
// with the name enclosed in double quotes.
func fmtColIdentQuoted(id analysis.ColIdent) string {
	if len(id.Qualifier) > 0 {
		return id.Qualifier + `."` + id.Name + `"`
	}
	return `"` + id.Name + `"`
}

////////////////////////////////////////////////////////////////////////////////
// Misc.
//

var reservedFilterMethodNames = map[string]struct{}{
	"UnmarshalFQL":  struct{}{},
	"UnmarshalSort": struct{}{},
	"TextSearch":    struct{}{},
	"AND":           struct{}{},
	"OR":            struct{}{},
}

var sqlQUANTIFIER = map[analysis.Quantifier]SQL.QUANTIFIER{
	analysis.QuantAny:  SQL.ANY,
	analysis.QuantSome: SQL.SOME,
	analysis.QuantAll:  SQL.ALL,
}

var sqlCMPOP = map[analysis.Predicate]SQL.CMPOP{
	analysis.IsEQ:   SQL.EQUAL,
	analysis.NotEQ:  SQL.NOT_EQUAL,
	analysis.NotEQ2: SQL.NOT_EQUAL2,
	analysis.IsLT:   SQL.LESS_THAN,
	analysis.IsGT:   SQL.GREATER_THAN,
	analysis.IsLTE:  SQL.LESS_THAN_EQUAL,
	analysis.IsGTE:  SQL.GREATER_THAN_EQUAL,
}

var sqlREGEXOP = map[analysis.Predicate]SQL.REGEXOP{
	analysis.IsMatch:   SQL.MATCH,
	analysis.IsMatchi:  SQL.MATCH_CI,
	analysis.NotMatch:  SQL.NOT_MATCH,
	analysis.NotMatchi: SQL.NOT_MATCH_CI,
}

var sqlTRUTH = map[analysis.Predicate]SQL.TRUTH{
	analysis.IsUnknown:  SQL.UNKNOWN,
	analysis.NotUnknown: SQL.UNKNOWN,
	analysis.IsTrue:     SQL.TRUE,
	analysis.NotTrue:    SQL.TRUE,
	analysis.IsFalse:    SQL.FALSE,
	analysis.NotFalse:   SQL.FALSE,
}

var sqlOverridingClause = map[analysis.OverridingKind]SQL.OverridingClause{
	analysis.OverridingSystem: "SYSTEM",
	analysis.OverridingUser:   "USER",
}

var sqlJoinType = map[analysis.JoinType]SQL.JoinType{
	analysis.JoinTypeLeft:  SQL.JoinLeft,
	analysis.JoinTypeRight: SQL.JoinRight,
	analysis.JoinTypeFull:  SQL.JoinFull,
	analysis.JoinTypeCross: SQL.JoinCross,
}
