package main

import (
	"bytes"
	"log"
	"strconv"

	GO "github.com/frk/gosql/internal/golang"
	SQL "github.com/frk/gosql/internal/sqlang"
)

const (
	filepreamble = ` DO NOT EDIT. This file was generated by "github.com/frk/gosql".`
	gosqlimport  = `github.com/frk/gosql`
	pgsqlimport  = `github.com/frk/gosql/pgsql`
)

var (
	idblank             = GO.Ident{"_"}
	idrecv              = GO.Ident{"q"}
	idconn              = GO.Ident{"c"}
	ididx               = GO.Ident{"i"}
	iderr               = GO.Ident{"err"}
	idnew               = GO.Ident{"new"}
	idnil               = GO.Ident{"nil"}
	idlen               = GO.Ident{"len"}
	idi64               = GO.Ident{"i64"}
	idres               = GO.Ident{"res"}
	idrow               = GO.Ident{"row"}
	idmake              = GO.Ident{"make"}
	idrows              = GO.Ident{"rows"}
	idexec              = GO.Ident{"Exec"}
	iderror             = GO.Ident{"error"}
	idparams            = GO.Ident{"params"}
	idafterscan         = GO.Ident{"AfterScan"}
	idquery             = GO.Ident{"queryString"}
	idiface             = GO.Ident{"interface{}"}
	idifaces            = GO.Ident{"[]interface{}"}
	idordinals          = GO.QualifiedIdent{"gosql", "OrdinalParameters"}
	sxconn              = GO.QualifiedIdent{"gosql", "Conn"}
	sxerrorinfo         = GO.QualifiedIdent{"gosql", "ErrorInfo"}
	sxexec              = GO.QualifiedIdent{"c", "Exec"}
	sxquery             = GO.QualifiedIdent{"c", "Query"}
	sxqueryrow          = GO.QualifiedIdent{"c", "QueryRow"}
	sxrowscan           = GO.QualifiedIdent{"row", "Scan"}
	sxrowsscan          = GO.QualifiedIdent{"rows", "Scan"}
	sxrowsclose         = GO.QualifiedIdent{"rows", "Close"}
	callrowserr         = GO.CallExpr{Fun: GO.QualifiedIdent{"rows", "Err"}}
	callrowsnext        = GO.CallExpr{Fun: GO.QualifiedIdent{"rows", "Next"}}
	callresrowsaffected = GO.CallExpr{Fun: GO.QualifiedIdent{"res", "RowsAffected"}}
	callinvaluelist     = GO.CallExpr{Fun: GO.QualifiedIdent{"gosql", "InValueList"}}
	calljson            = GO.CallExpr{Fun: GO.QualifiedIdent{"gosql", "JSON"}}
	callmakeparams      = GO.CallExpr{Fun: GO.Ident{"make"}, Args: GO.ArgsList{List: idifaces}}
)

// targetInfo holds the information for the analyzed and type checked target type.
type targetInfo struct {
	// Populated by the analyzer. Set to the dataField of either the queryStruct
	// or the filterStruct, depending on which one was analyzed.
	dataField *dataField
	// Populated by the analyzer. If the target is a query struct, then this
	// field will be set to the result of the query struct analysis, otherwise
	// it will remain uninitialized.
	query *queryStruct
	// Populated by the analyzer. If the target is a filter struct, then this
	// field will be set to the result of the filter struct analysis, otherwise
	// it will remain uninitialized.
	filter *filterStruct

	// Populated by the type checker. A fieldColumnInfo slice that holds
	// the data source fields and their corresponding target columns into
	// which the data is stored.
	input []*fieldColumnInfo
	// Populated by the type checker. A fieldColumnInfo slice that holds
	// the data target fields and their corresponding source columns from
	// which the data is read.
	output []*fieldColumnInfo
	// Populated by the type checker. A list of fieldColumnInfos that
	// represent the primary key of the target relation.
	primaryKeys []*fieldColumnInfo
	// Populated by the type checker and used by the generator to get the
	// correct represenation of the database type of the column that's
	// associated with a predicate's field.
	searchConditionFieldColumns map[*searchConditionField]*pgcolumn
	// Set by the type checker. Info on the index to be used for an ON CONFLICT clause.
	onConflictIndex *pgindex
}

// fieldColumnInfo holds the combined field-column information from the analyzer,
// the type checker, and the generator.
type fieldColumnInfo struct {
	// The result of the data type's field analysis.
	field *fieldInfo
	// The field's corresponding column.
	column *pgcolumn
	// The column identifier.
	colId colId
	// The column SQL expression.
	sqlExpr SQL.ValueExpr

	// TODO
	pgsql pgTypeEntry
}

// skipwrite is a helper method that reports whether or not the field's column should be written to.
func (ti *targetInfo) skipwrite(fc *fieldColumnInfo) bool {
	return fc.field.readOnly && (ti.query.forceList == nil ||
		(ti.query.forceList.all == false && !ti.query.forceList.contains(fc.colId)))
}

// skipread is a helper method that reports whether or not the field's column should be read from.
func (ti *targetInfo) skipread(fc *fieldColumnInfo) bool {
	return fc.field.writeOnly && (ti.query.forceList == nil ||
		(ti.query.forceList.all == false && !ti.query.forceList.contains(fc.colId)))
}

// usedefault is a helper method that reports whether or not the SQL's DEFAULT
// marker should be used to write a column.
func (ti *targetInfo) usedefault(fc *fieldColumnInfo) bool {
	return fc.field.useDefault || (ti.query.defaultList != nil &&
		(ti.query.defaultList.all || ti.query.defaultList.contains(fc.colId)))
}

// skipinit is a helper method that reports whether or not the GO output
// fields should be, if they are pointers, initialized.
func (ti *targetInfo) skipinit() bool {
	return (ti.query.kind == queryKindInsert || ti.query.kind == queryKindUpdate) && // has input fields?
		(ti.query.resultField == nil) // scan output into input fields?
}

type generator struct {
	infos   []*targetInfo
	pkgName string
	buf     bytes.Buffer

	keytag  string
	keysep  string
	keybase bool
	keyfunc func(*fieldColumnInfo) string

	file GO.File

	// file specific state
	imports  GO.ImportDecl
	addpgsql bool

	// query specific state, needs to be reset on each iteration
	ti         *targetInfo
	nparam     int               // number of parameters
	asvar      bool              // if true, the query string should be declared as a var, not const.
	fclose     bool              // if true, the SQL query needs to be closed (with right parentheses) after the filter's been added.
	insx       []GO.SelectorExpr // slice fields for IN clauses
	queryargs  []GO.ExprNode     // list of arguments to be passed to the query (Exec|Query|QueryRow)
	scanargs   []GO.ExprNode     // list of arguments to be passed to the Scan method
	argroot    GO.ExprNode       // the root node for the fields to be passed as arguments to the query
	scanroot   GO.ExprNode       // the root node for the fields to be scanned
	scaninits  GO.StmtList       // list of pointer initializations for scanning nested fields
	lofallback GO.StmtList

	outputcolumns SQL.ValueExprList //
	sqltailnode   SQL.Node          //
	// scantoinput indicates that the output of the query should be scanned
	// into the input of the query, which in an insert or update is already
	// allocated and therefore needs no initialization.
	scantoinput bool

	sqlInputColumns  SQL.NameGroup
	sqlInputColumns2 SQL.NameGroup
	sqlInputValues   SQL.ValueExprList //
	sqlInputValues2  SQL.ValueExprList //
}

func (g *generator) run(pkgName string) error {
	g.resolveKeyFunc()

	for _, ti := range g.infos {
		g.ti = ti
		g.nparam = 0
		g.asvar = false
		g.fclose = false
		g.insx = nil
		g.queryargs = nil
		g.scanargs = nil
		g.argroot = nil
		g.scanroot = nil
		g.scaninits = nil
		g.lofallback = nil
		g.outputcolumns = nil
		g.sqltailnode = nil
		g.scantoinput = false

		g.sqlInputColumns = nil
		g.sqlInputColumns2 = nil
		g.sqlInputValues = nil
		g.sqlInputValues2 = nil

		if ti.query != nil {
			execdecl := g.buildQueryCode(ti)
			g.file.Decls = append(g.file.Decls, execdecl)
		}

		if ti.filter != nil {
			decls := g.buildFilterCode(ti)
			g.file.Decls = append(g.file.Decls, decls...)
		}
	}

	g.imports.Specs = append(g.imports.Specs, GO.ImportSpec{Doc: GO.NL{}, Path: gosqlimport})
	if g.addpgsql {
		g.imports.Specs = append(g.imports.Specs, GO.ImportSpec{Path: pgsqlimport})
	}

	g.file.PkgName = pkgName
	g.file.Preamble = GO.LineComment{filepreamble}
	g.file.Imports = []GO.ImportDeclNode{g.imports}

	return GO.Write(g.file, &g.buf)
}

// buildFilterCode
func (g *generator) buildFilterCode(ti *targetInfo) (decls []GO.TopLevelDeclNode) {
	mapId, columnMap := g.buildFilterMap(ti)
	fqlMethod := g.buildFilterUnmarshalFQLMethod(ti, mapId)
	sortMethod := g.buildFilterUnmarshalSortMethod(ti, mapId)
	searchMethod := g.buildFilterTextSearchMethod(ti)
	columnMethods := g.buildFilterColumnMethodList(ti, mapId)
	andMethod := g.buildFilterBoolOpMethod(ti, "AND")
	orMethod := g.buildFilterBoolOpMethod(ti, "OR")

	decls = append(decls, columnMap, fqlMethod, sortMethod, searchMethod)
	decls = append(decls, columnMethods...)
	decls = append(decls, andMethod, orMethod)
	return decls
}

func (g *generator) buildFilterMap(ti *targetInfo) (mapId GO.Ident, mapDecl GO.VarDecl) {
	mapId.Name = "_" + ti.filter.name + "_colmap"

	elems := make([]GO.KeyElement, 0)
	keyset := make(map[string]struct{})
	for _, item := range ti.input {
		key := g.keyfunc(item) //.field.tag.First("json")
		if _, ok := keyset[key]; ok {
			continue
		}
		keyset[key] = struct{}{}

		var e GO.KeyElement
		e.Key = GO.StringLit(key)
		e.Value = GO.RawStringLit(item.colId.quoted())
		elems = append(elems, e)
	}

	mapDecl.Spec = GO.ValueSpec{
		Names: mapId,
		Values: GO.MapLit{
			Type:  GO.MapType{Key: GO.Ident{"string"}, Value: GO.Ident{"string"}},
			Elems: elems,
		},
	}
	return mapId, mapDecl
}

func (g *generator) buildFilterUnmarshalFQLMethod(ti *targetInfo, mapId GO.Ident) (m GO.MethodDecl) {
	m.Recv.Name.Name = "f"
	m.Recv.Type = GO.PointerRecvType{ti.filter.name}
	m.Name.Name = "UnmarshalFQL"
	m.Type.Params = GO.ParamList{{Names: GO.Ident{"fqlString"}, Type: GO.Ident{"string"}}}
	m.Type.Results = GO.ParamList{{Type: GO.Ident{"error"}}}
	m.Body.List = []GO.StmtNode{GO.ReturnStmt{GO.CallExpr{
		Fun:  GO.Ident{"f.Filter.UnmarshalFQL"},
		Args: GO.ArgsList{List: GO.ExprList{GO.Ident{"fqlString"}, mapId, GO.False}},
	}}}
	return m
}

func (g *generator) buildFilterUnmarshalSortMethod(ti *targetInfo, mapId GO.Ident) (m GO.MethodDecl) {
	m.Recv.Name.Name = "f"
	m.Recv.Type = GO.PointerRecvType{ti.filter.name}
	m.Name.Name = "UnmarshalSort"
	m.Type.Params = GO.ParamList{{Names: GO.Ident{"sortString"}, Type: GO.Ident{"string"}}}
	m.Type.Results = GO.ParamList{{Type: GO.Ident{"error"}}}
	m.Body.List = []GO.StmtNode{GO.ReturnStmt{GO.CallExpr{
		Fun:  GO.Ident{"f.Filter.UnmarshalSort"},
		Args: GO.ArgsList{List: GO.ExprList{GO.Ident{"sortString"}, mapId, GO.False}},
	}}}
	return m
}

func (g *generator) buildFilterTextSearchMethod(ti *targetInfo) (m GO.MethodDecl) {
	m.Recv.Name.Name = "f"
	m.Recv.Type = GO.PointerRecvType{ti.filter.name}
	m.Name.Name = "TextSearch"
	m.Type.Params = GO.ParamList{{Names: GO.Ident{"v"}, Type: GO.Ident{"string"}}}
	if cid := ti.filter.textSearchColId; cid != nil {
		m.Body.List = []GO.StmtNode{GO.ExprStmt{GO.CallExpr{
			Fun:  GO.Ident{"f.Filter.TextSearch"},
			Args: GO.ArgsList{List: GO.ExprList{GO.RawStringLit(cid.quoted()), GO.Ident{"v"}}},
		}}}
	} else {
		m.Body.List = []GO.StmtNode{GO.LineComment{" No search document specified."}}
	}
	return m
}

func (g *generator) buildFilterColumnMethodList(ti *targetInfo, mapId GO.Ident) (mm []GO.TopLevelDeclNode) {
	var (
		f   = GO.Ident{"f"}   // the receiver name
		op  = GO.Ident{"op"}  // the operator argument name
		val = GO.Ident{"val"} // the value argument name
	)

	for _, item := range ti.input {
		var m GO.MethodDecl

		// the method's receiver
		m.Recv.Name = f
		m.Recv.Type = GO.PointerRecvType{ti.filter.name}

		// the method's name
		for _, node := range item.field.path {
			// If the field's nested, concatenate the names of the parent fields.
			//
			// TODO(mkopriva): reconsider concatenating without prejudice, might
			// be better to omit embedded fields, so that the method name match
			// the corresponding field selection ability.
			// NOTE(mkopriva): keep in mind that if the above TODO item is implemented,
			// it will be important to keep track of the field "promotion hierarchy",
			// i.e. two fields with the same name, nested in embedded fields, but at
			// different depths...
			m.Name.Name += node.name
		}
		m.Name.Name += item.field.name
		if _, ok := filterMethodNamesReserved[m.Name.Name]; ok {
			continue // skip if name is reserved
		}

		if typ := item.field.typ; typ.isImported {
			g.addimport(typ.pkgPath, typ.pkgName, typ.pkgLocal)
		}

		// the method's input and output arguments
		m.Type.Params = GO.ParamList{
			{Names: op, Type: GO.Ident{"string"}},
			{Names: val, Type: GO.Ident{item.field.typ.nameOrLiteral(true)}},
		}
		m.Type.Results = GO.ParamList{{Type: GO.PointerType{GO.Ident{ti.filter.name}}}}

		// the method's body
		m.Body.List = []GO.StmtNode{
			GO.ExprStmt{GO.CallExpr{
				Fun:  GO.Ident{"f.Filter.Col"},
				Args: GO.ArgsList{List: GO.ExprList{GO.RawStringLit(item.colId.quoted()), op, val}},
			}},
			GO.ReturnStmt{f},
		}
		mm = append(mm, m)
	}
	return mm
}

func (g *generator) buildFilterBoolOpMethod(ti *targetInfo, name string) (m GO.MethodDecl) {
	var (
		f     = GO.Ident{"f"}                      // method's receiver name
		typ   = GO.PointerRecvType{ti.filter.name} // method's reciever type
		nest  = GO.Ident{"nest"}                   // method's argument name
		ftype = GO.PointerType{GO.QualifiedIdent{"gosql", "Filter"}}
	)
	m.Recv.Name = f
	m.Recv.Type = typ
	m.Name.Name = name

	// the method's input and output arguments
	m.Type.Params = GO.ParamList{
		{Names: nest, Type: GO.FuncType{Params: GO.ParamList{{Type: typ}}}, Variadic: true},
	}
	m.Type.Results = GO.ParamList{{Type: typ}}

	// the method's body
	m.Body.List = []GO.StmtNode{
		GO.IfStmt{
			Cond: GO.BinaryExpr{X: GO.CallLenExpr{nest}, Op: GO.BinaryEql, Y: GO.IntLit(0)},
			Body: GO.BlockStmt{[]GO.StmtNode{
				GO.ExprStmt{GO.CallExpr{Fun: GO.Ident{"f.Filter." + name}}},
				GO.ReturnStmt{f},
			}},
		},
		GO.ExprStmt{GO.CallExpr{
			Fun: GO.Ident{"f.Filter." + name},
			Args: GO.ArgsList{List: GO.ExprList{GO.FuncLit{
				Type: GO.FuncType{Params: GO.ParamList{{Names: idblank, Type: ftype}}},
				Body: GO.BlockStmt{[]GO.StmtNode{
					GO.ExprStmt{GO.CallExpr{
						Fun:  GO.IndexExpr{X: nest, Index: GO.IntLit(0)},
						Args: GO.ArgsList{List: f},
					}},
				}},
			}}},
		}},
		GO.ReturnStmt{f},
	}
	return m
}

// buildQueryCode
func (g *generator) buildQueryCode(ti *targetInfo) (m GO.MethodDecl) {
	m.Name = idexec
	m.Recv.Name = idrecv
	m.Recv.Type = GO.PointerRecvType{ti.query.name}
	m.Type.Params = GO.ParamList{{Names: idconn, Type: sxconn}}
	m.Type.Results = GO.ParamList{{Type: iderror}}

	g.scantoinput = ((ti.query.kind == queryKindInsert || ti.query.kind == queryKindUpdate) &&
		ti.query.dataField.data.isSlice && ti.query.resultField == nil)

	g.prepareInput(ti)
	g.prepareOutput(ti)

	g.prepareGOLimitOffsetFallback(ti)

	m.Body.Add(g.buildquerystring(ti))
	m.Body.Add(g.buildGOFilterParams(ti))

	if len(g.lofallback) > 0 {
		m.Body.Add(g.lofallback)
	}

	m.Body.Add(g.queryexec(ti))
	m.Body.Add(g.returnstmt(ti))
	return m
}

// prepareInput
func (g *generator) prepareInput(ti *targetInfo) {
	// prepare input for the INSERT / UPDATE query
	if len(ti.input) > 0 {
		g.prepareGOInputFields(ti)
		g.prepareSQLInputColumns(ti)
	}

	// prepare input for the WHERE clause
	if ti.query.whereBlock != nil && len(ti.query.whereBlock.conds) > 0 {
		sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{ti.query.whereBlock.name}}
		g.prepareGOInputWhereFields(ti.query.whereBlock.conds, sx)
	} else if ti.query.kind == queryKindUpdate && (ti.query.all == false && ti.query.filterField == "") {
		g.prepareGOInputPrimaryKeyFields(ti)
	}

	// prepare input for the LIMIT clause
	if ti.query.limitField != nil && len(ti.query.limitField.name) > 0 {
		sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{ti.query.limitField.name}}
		g.queryargs = append(g.queryargs, sx)
	}

	// prepare input for the OFFSET clause
	if ti.query.offsetField != nil && len(ti.query.offsetField.name) > 0 {
		sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{ti.query.offsetField.name}}
		g.queryargs = append(g.queryargs, sx)
	}
}

// prepareGOInputFields prepares a list of GO field selector expressions
// that will be passed as arguments to the query executing function.
func (g *generator) prepareGOInputFields(ti *targetInfo) {
	data := ti.query.dataField.data
	name := ti.query.dataField.name

	// the root node for the fields to be stored
	g.argroot = GO.ExprNode(GO.SelectorExpr{X: idrecv, Sel: GO.Ident{name}})
	if data.isSlice {
		g.argroot = GO.Ident{"v"}
	}

	for _, item := range ti.input {
		if ti.skipwrite(item) { // read only?
			continue
		}
		if ti.usedefault(item) { // DEFAULT?
			continue
		}

		// the GO field to be passed as argument
		fx := g.argroot
		for _, node := range item.field.path {
			fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{node.name}}
		}
		fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{item.field.name}}
		fx = g.transformGOInputFieldExpr(fx, item)
		g.queryargs = append(g.queryargs, fx)
	}
}

// transformGOInputFieldExpr produces an expression that, *if* necessary,
// transforms the field's Go value into the corresponding column's postgres value.
func (g *generator) transformGOInputFieldExpr(x GO.ExprNode, fc *fieldColumnInfo) GO.ExprNode {
	if len(fc.pgsql.valuer) > 0 {
		g.addpgsql = true
		call := GO.CallExpr{Fun: GO.QualifiedIdent{"pgsql", fc.pgsql.valuer}}
		call.Args = GO.ArgsList{List: x}
		return call
	}
	return x
}

// prepareSQLInputColumns prepares the target columns for an INSERT or UPDATE
// query, including a list of the SQL parameter placeholders or values.
func (g *generator) prepareSQLInputColumns(ti *targetInfo) {
	updateWithSlice := (ti.query.kind == queryKindUpdate && ti.query.dataField.data.isSlice)

	for _, item := range ti.input {
		if ti.skipwrite(item) { // read only?
			continue
		}

		// the target column
		g.sqlInputColumns = append(g.sqlInputColumns, SQL.Name(item.column.name))

		if ti.usedefault(item) {
			g.sqlInputValues = append(g.sqlInputValues, SQL.DEFAULT)
			continue
		}

		if updateWithSlice {
			var col SQL.ColumnIdent
			col.Name = SQL.Name(item.column.name)
			col.Qual = "x"

			var cast SQL.CastExpr
			cast.Expr = col
			cast.Type = item.column.typ.name
			g.sqlInputValues = append(g.sqlInputValues, cast)
			continue
		}

		// the parameter placeholder
		item.sqlExpr = g.sqlparam()
		g.sqlInputValues = append(g.sqlInputValues, item.sqlExpr)
	}

	if updateWithSlice {
		for _, item := range ti.primaryKeys {
			// TODO documentation
			if !ti.skipwrite(item) { // read only?
				continue
			}
			g.sqlInputColumns2 = append(g.sqlInputColumns2, SQL.Name(item.column.name))

			item.sqlExpr = g.sqlparam()
			g.sqlInputValues2 = append(g.sqlInputValues2, item.sqlExpr)
		}
	}
}

// prepareGOInputWhereFields prepares the input for a WHERE clause which is a list of
// the GO "where block" fields that will be passed to the query executing function.
func (g *generator) prepareGOInputWhereFields(conds []*searchCondition, sx GO.SelectorExpr) {
	for _, item := range conds {
		switch cond := item.cond.(type) {
		case *searchConditionNested:
			g.prepareGOInputWhereFields(cond.conds, GO.SelectorExpr{X: sx, Sel: GO.Ident{cond.name}})
			continue
		case *searchConditionBetween:
			if x, ok := cond.x.(*fieldDatum); ok {
				sx := GO.SelectorExpr{X: sx, Sel: GO.Ident{cond.name}}
				sx = GO.SelectorExpr{X: sx, Sel: GO.Ident{x.name}}
				g.queryargs = append(g.queryargs, sx)
			}
			if y, ok := cond.y.(*fieldDatum); ok {
				sx := GO.SelectorExpr{X: sx, Sel: GO.Ident{cond.name}}
				sx = GO.SelectorExpr{X: sx, Sel: GO.Ident{y.name}}
				g.queryargs = append(g.queryargs, sx)
			}
		case *searchConditionField:
			if cond.pred != isIn && cond.pred != notIn {
				var x GO.ExprNode

				x = GO.SelectorExpr{X: sx, Sel: GO.Ident{cond.name}}
				if cond.qua > 0 {

					gotyp := cond.typ.goTypeId(false, false, true)
					oid := g.ti.searchConditionFieldColumns[cond].typ.oid.getArrayOID()

					if entry, ok := pgTypeTable[pgTypeKey{oid: oid}][gotyp]; !ok {
						// TODO should not happen here, this should be caught while scanning the db
						log.Fatalf("unsupported type conversion: %s - %d", gotyp, oid)
					} else if len(entry.valuer) > 0 {
						g.addpgsql = true
						sel := GO.SelectorExpr{X: GO.Ident{"pgsql"}, Sel: GO.Ident{entry.valuer}}
						x = GO.CallExpr{Fun: sel, Args: GO.ArgsList{List: x}}
					}
				}

				g.queryargs = append(g.queryargs, x)
			}
		case *searchConditionColumn:
			// nothing to do
		}
	}
}

// prepareGOInputPrimaryKeyFields prepares the input for a WHERE clause
// using the primary key(s) of the data type.
func (g *generator) prepareGOInputPrimaryKeyFields(ti *targetInfo) {
	for _, item := range ti.primaryKeys {
		if !ti.skipwrite(item) {
			continue
		}

		fx := GO.ExprNode(g.argroot)
		for _, node := range item.field.path {
			fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{node.name}}
		}
		fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{item.field.name}}
		g.queryargs = append(g.queryargs, fx)
	}
}

// prepareGOLimitOffsetFallback
func (g *generator) prepareGOLimitOffsetFallback(ti *targetInfo) {
	if field := ti.query.limitField; field != nil && field.value > 0 && len(field.name) > 0 {
		sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{field.name}}

		asn := GO.AssignStmt{Token: GO.Assign}
		asn.Lhs = sx
		asn.Rhs = GO.IntLit(field.value)

		ifzero := GO.IfStmt{}
		ifzero.Cond = GO.BinaryExpr{X: sx, Op: GO.BinaryEql, Y: GO.IntLit(0)}
		ifzero.Body = GO.BlockStmt{List: []GO.StmtNode{asn}}
		g.lofallback = append(g.lofallback, ifzero)
	}

	if field := ti.query.offsetField; field != nil && field.value > 0 && len(field.name) > 0 {
		sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{field.name}}

		asn := GO.AssignStmt{Token: GO.Assign}
		asn.Lhs = sx
		asn.Rhs = GO.IntLit(field.value)

		ifzero := GO.IfStmt{}
		ifzero.Cond = GO.BinaryExpr{X: sx, Op: GO.BinaryEql, Y: GO.IntLit(0)}
		ifzero.Body = GO.BlockStmt{List: []GO.StmtNode{asn}}
		g.lofallback = append(g.lofallback, ifzero)
	}

	if len(g.lofallback) > 0 {
		g.lofallback = append(g.lofallback, GO.NL{})
	}
}

// prepareOutput .................
func (g *generator) prepareOutput(ti *targetInfo) {
	if len(ti.output) > 0 {
		skipinit := ti.skipinit()
		g.prepareOutputGORoot(ti, skipinit)
		g.prepareOutputGORootFields(ti, skipinit)
		g.prepareOutputSQLColumns(ti)
	}
}

// prepareOutputGORoot resolves the GO root expression of the fields into which
// the output will be scanned, additionally if the root needs to be initialized
// before scanning, an initialization statement will be prepared as well.
func (g *generator) prepareOutputGORoot(ti *targetInfo, skipinit bool) {
	data := ti.query.dataField.data
	name := ti.query.dataField.name
	if ti.query.resultField != nil {
		data = ti.query.resultField.data
		name = ti.query.resultField.name
	}

	g.scanroot = GO.ExprNode(GO.SelectorExpr{X: idrecv, Sel: GO.Ident{name}})
	if data.isSlice && skipinit {
		g.scanroot = GO.IndexExpr{X: g.scanroot, Index: GO.Ident{"i"}}
	} else if data.isSlice || data.isIter {
		g.scanroot = GO.Ident{"v"}
	}

	if !skipinit {
		// build the initialization statement for the g.scanroot node
		var rootinit GO.StmtNode
		if !data.isSlice && !data.isIter && data.isPointer {
			g.scaninits = append(g.scaninits, GO.NL{})

			init := GO.AssignStmt{Token: GO.Assign}
			init.Lhs, init.Rhs = g.scanroot, GO.CallNewExpr{g.rectype(data)}
			rootinit = init
		} else if (data.isSlice || data.isIter) && data.isPointer {
			init := GO.AssignStmt{Token: GO.AssignDefine}
			init.Lhs, init.Rhs = g.scanroot, GO.CallNewExpr{g.rectype(data)}
			rootinit = init
		} else if (data.isSlice || data.isIter) && !data.isPointer {
			init := GO.VarDecl{}
			init.Spec = GO.ValueSpec{Names: GO.Ident{"v"}, Type: g.rectype(data)}
			rootinit = GO.DeclStmt{init}
		}
		if rootinit != nil {
			g.scaninits = append(g.scaninits, rootinit)
		}
	}
}

// prepareOutputGORootFields ....
func (g *generator) prepareOutputGORootFields(ti *targetInfo, skipinit bool) {
	// done is used to keep track of pointer fields whose
	// initialization statements have already been created
	var done = make(map[string]bool)

	for _, item := range ti.output {
		if ti.skipread(item) { // writeonly?
			continue
		}

		key := "" // key for the done map

		fx := g.scanroot
		for _, node := range item.field.path {
			fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{node.name}}

			if skipinit {
				continue
			}

			key += node.name
			if node.isPointer && !done[key] {
				if node.isImported {
					g.addimport(node.typePkgPath, node.typePkgName, node.typePkgLocal)
				}

				// nested pointer field initialization statement
				init := GO.AssignStmt{Token: GO.Assign}
				init.Lhs, init.Rhs = fx, GO.CallNewExpr{g.pathelemtype(node)}
				g.scaninits = append(g.scaninits, init)

				done[key] = true
			}
		}

		fx = GO.SelectorExpr{X: fx, Sel: GO.Ident{item.field.name}}
		fx = GO.UnaryExpr{Op: GO.UnaryAmp, X: fx}
		fx = g.transformOutputGOFieldExpr(fx, item)
		g.scanargs = append(g.scanargs, fx)
	}
}

// transformOutputGOFieldExpr ...
func (g *generator) transformOutputGOFieldExpr(x GO.ExprNode, fc *fieldColumnInfo) GO.ExprNode {
	if len(fc.pgsql.scanner) > 0 {
		g.addpgsql = true
		call := GO.CallExpr{Fun: GO.QualifiedIdent{"pgsql", fc.pgsql.scanner}}
		call.Args = GO.ArgsList{List: x}
		return call
	}
	return x
}

// prepareOutputSQLColumns prepares the list of SQL columns to be returned by the query.
func (g *generator) prepareOutputSQLColumns(ti *targetInfo) {
	for _, item := range ti.output {
		if ti.skipread(item) { // writeonly?
			continue
		}

		// TODO(mkopriva):
		// - check whether or not the column can be NULL and if so add a COALESCE
		// - check whether or not the field has the "usecoalesce" flag set to true and if so add a COALESCE
		// - ... anything else?
		g.outputcolumns = append(g.outputcolumns, g.sqlcolref(item.colId))
	}
}

func (g *generator) buildquerystring(ti *targetInfo) (stmt GO.StmtNode) {

	sqlnode := g.sqlnode(ti)

	var decl GO.DeclNode
	if g.declarevar(ti) {
		decl = GO.VarDecl{Spec: GO.ValueSpec{
			Names:   idquery,
			Values:  GO.RawStringNode{N: sqlnode},
			Comment: GO.LineComment{" `"},
		}}
	} else {
		decl = GO.ConstDecl{Spec: GO.ValueSpec{
			Names:   idquery,
			Values:  GO.RawStringNode{N: sqlnode},
			Comment: GO.LineComment{" `"},
		}}
	}

	if (ti.query.kind == queryKindInsert || ti.query.kind == queryKindUpdate) && ti.query.dataField.data.isSlice {
		result := GO.StmtList{GO.DeclStmt{decl}, GO.NL{}}

		idrel := GO.QualifiedIdent{idrecv.Name, ti.query.dataField.name}
		numfields := GO.IntLit(len(g.queryargs))

		if len(g.queryargs) > 0 {
			// params := make([]interface{}, len(q.T)*numoffields)
			asn := GO.AssignStmt{Token: GO.AssignDefine}
			asn.Lhs = idparams
			asn.Rhs = GO.CallMakeExpr{
				Type: idifaces,
				Size: GO.BinaryExpr{
					Op: GO.BinaryMul,
					X:  GO.CallLenExpr{idrel},
					Y:  numfields,
				},
			}
			result = append(result, asn)
		}

		// for i, v := range q.DataSlice {
		loop := GO.ForStmt{}
		{
			if len(g.queryargs) > 0 {
				// for i, v := range q.DataSlice {
				rangeclause := GO.ForRangeClause{}
				rangeclause.Key = GO.Ident{"i"}
				rangeclause.Value = GO.Ident{"v"}
				rangeclause.X = idrel
				rangeclause.Define = true
				loop.Clause = rangeclause

				// pos := i * 4
				asn2 := GO.AssignStmt{Token: GO.AssignDefine}
				asn2.Lhs = GO.Ident{"pos"}
				asn2.Rhs = GO.BinaryExpr{Op: GO.BinaryMul, X: GO.Ident{"i"}, Y: numfields}
				loop.Body = GO.BlockStmt{List: []GO.StmtNode{asn2, GO.NL{}}}

				// params[pos+123] = v.SomeField
				assigns := make([]GO.StmtNode, len(g.queryargs))
				for i, item := range g.queryargs {
					indx := GO.BinaryExpr{Op: GO.BinaryAdd, X: GO.Ident{"pos"}, Y: GO.IntLit(i)}
					asn3 := GO.AssignStmt{Token: GO.Assign}
					asn3.Lhs = GO.IndexExpr{X: idparams, Index: indx}
					asn3.Rhs = item
					assigns[i] = asn3
				}
				loop.Body.List = append(loop.Body.List, assigns...)
				loop.Body.List = append(loop.Body.List, GO.NL{})
			} else {
				// for _, _ := range q.DataSlice {
				rangeclause := GO.ForRangeClause{}
				rangeclause.Key = GO.Ident{"_"}
				rangeclause.Value = GO.Ident{"_"}
				rangeclause.X = idrel
				loop.Clause = rangeclause
			}

			////////////////////////////////////////////////////////
			numdefs := 0
			numvals := len(g.sqlInputValues) + len(g.sqlInputValues2)
			concats := make([]GO.ExprNode, numvals+1) // +1 for the final `),`
			for i, item := range append(g.sqlInputValues, g.sqlInputValues2...) {
				sep := `, `
				if i == 0 {
					sep = `(`
				}

				if item == SQL.DEFAULT {
					numdefs += 1
					concats[i] = GO.RawStringLit(sep + `DEFAULT`)
				} else {
					idxexpr := GO.BinaryExpr{Op: GO.BinaryAdd,
						X: GO.Ident{"pos"}, Y: GO.IntLit(i - numdefs),
					}

					// `, ` + gosql.OrdinalParameters[pos+2] +
					concat := GO.BinaryExpr{Op: GO.BinaryAdd}
					concat.X = GO.RawStringLit(sep)
					concat.Y = GO.IndexExpr{X: idordinals, Index: idxexpr}
					concats[i] = concat
				}
			}

			concats[len(concats)-1] = GO.RawStringLit(`),`)

			asn4 := GO.AssignStmt{Token: GO.AssignAdd}
			asn4.Lhs = idquery
			asn4.Rhs = GO.MultiLineExpr{Op: GO.BinaryAdd, Exprs: concats}

			loop.Body.List = append(loop.Body.List, asn4)
		}
		result = append(result, loop)

		asn5 := GO.AssignStmt{Token: GO.Assign}
		asn5.Lhs = idquery
		asn5.Rhs = GO.SliceExpr{X: idquery,
			High: GO.BinaryExpr{Op: GO.BinarySub, X: GO.CallLenExpr{idquery}, Y: GO.IntLit(1)},
		}
		result = append(result, GO.NL{}, asn5)

		if g.sqltailnode != nil {
			asn6 := GO.AssignStmt{Token: GO.AssignAdd}
			asn6.Lhs = idquery
			asn6.Rhs = GO.RawStringNode{Prefix: " ", N: g.sqltailnode, Comment: &GO.LineComment{" `"}}
			result = append(result, asn6)
		}
		return result

	} else if len(g.insx) > 0 {
		// prepare the var declarations
		vardecl := GO.VarDecl{}

		nstatic := GO.ValueSpec{}
		nstatic.Names = GO.Ident{"nstatic"}
		nstatic.Values = GO.IntLit(g.nparam)
		nstatic.Comment = GO.LineComment{" number of static parameters"}

		specs := GO.ValueSpecList{nstatic}
		for i, sx := range g.insx {
			num := strconv.Itoa(i + 1)

			lenspec := GO.ValueSpec{}
			lenspec.Names = GO.Ident{"len" + num}
			lenspec.Values = GO.CallExpr{Fun: idlen, Args: GO.ArgsList{List: sx}}
			lenspec.Comment = GO.LineComment{" length of slice #" + num + " to be unnested"}

			posspec := GO.ValueSpec{}
			posspec.Names = GO.Ident{"pos" + num}
			if i == 0 {
				// the first position is set to the value of nstatic
				posspec.Values = GO.Ident{"nstatic"}
			} else {
				// the rest of the positions are calculated from
				// adding the previous length to the previous position
				prev := strconv.Itoa(i)
				prevlen, prevpos := GO.Ident{"len" + prev}, GO.Ident{"pos" + prev}
				posspec.Values = GO.BinaryExpr{X: prevpos, Op: GO.BinaryAdd, Y: prevlen}
			}
			posspec.Comment = GO.LineComment{" starting position of slice #" + num + " parameters"}

			specs = append(specs, lenspec, posspec)
		}
		vardecl.Spec = specs

		// next is the query declaration
		list := GO.StmtList{GO.DeclStmt{vardecl}, GO.NL{}, GO.DeclStmt{decl}, GO.NL{}}

		// define the params variable
		asn := GO.AssignStmt{Token: GO.AssignDefine}
		asn.Lhs = idparams
		callmake := callmakeparams
		bin := GO.BinaryExpr{X: GO.Ident{"nstatic"}, Op: GO.BinaryAdd, Y: GO.Ident{"len1"}}
		for i := 1; i < len(g.insx); i++ {
			y := GO.Ident{"len" + strconv.Itoa(i+1)}
			bin = GO.BinaryExpr{X: bin, Op: GO.BinaryAdd, Y: y}
		}
		callmake.Args.AddExprs(bin)
		asn.Rhs = callmake
		list = append(list, asn)

		// directly assign non-slice params
		for i, arg := range g.queryargs {
			asn := GO.AssignStmt{Token: GO.Assign}
			asn.Lhs = GO.IndexExpr{X: idparams, Index: GO.IntLit(i)}
			asn.Rhs = arg
			list = append(list, asn)
		}

		for i, sx := range g.insx {
			lenid := GO.Ident{"len" + strconv.Itoa(i+1)}
			posid := GO.Ident{"pos" + strconv.Itoa(i+1)}

			forclause := GO.ForClause{}
			forclause.Init = GO.AssignStmt{Token: GO.AssignDefine, Lhs: ididx, Rhs: GO.IntLit(0)}
			forclause.Cond = GO.BinaryExpr{X: ididx, Op: GO.BinaryLss, Y: lenid}
			forclause.Post = GO.IncDecStmt{X: ididx, Token: GO.IncDecIncrement}
			loop := GO.ForStmt{Clause: forclause}

			asn := GO.AssignStmt{Token: GO.Assign}
			asn.Lhs = GO.IndexExpr{X: idparams, Index: GO.BinaryExpr{X: posid, Op: GO.BinaryAdd, Y: ididx}}
			asn.Rhs = GO.IndexExpr{X: sx, Index: ididx}

			loop.Body = GO.BlockStmt{List: []GO.StmtNode{asn}}

			list = append(list, loop)
		}

		return append(list, GO.NL{})
	} else if len(ti.query.filterField) > 0 {
		list := GO.StmtList{GO.DeclStmt{decl}, GO.NL{}}

		// q.Filter.ToSQL()
		stmt := GO.AssignStmt{Token: GO.AssignAdd}
		stmt.Lhs = idquery
		stmt.Rhs = GO.CallExpr{Fun: GO.SelectorExpr{
			X:   GO.SelectorExpr{X: idrecv, Sel: GO.Ident{ti.query.filterField}},
			Sel: GO.Ident{"ToSQL"},
		}}
		list = append(list, stmt)

		if g.sqltailnode != nil {
			stmt := GO.AssignStmt{Token: GO.AssignAdd}
			stmt.Lhs = idquery
			stmt.Rhs = GO.RawStringNode{Prefix: " ", N: g.sqltailnode, Comment: &GO.LineComment{" `"}}
			list = append(list, stmt)
		}
		if g.fclose {
			stmt := GO.AssignStmt{Token: GO.AssignAdd}
			stmt.Lhs = idquery
			stmt.Rhs = GO.RawStringLit(`)`)
			list = append(list, stmt)
		}
		list = append(list, GO.NL{})
		return list
	}
	return GO.StmtList{GO.DeclStmt{decl}, GO.NL{}}
}

func (g *generator) buildGOFilterParams(ti *targetInfo) (stmt GO.StmtNode) {
	if len(ti.query.filterField) > 0 {
		var list GO.StmtList

		// q.Filter.Params()
		call := GO.CallExpr{Fun: GO.SelectorExpr{
			X:   GO.SelectorExpr{X: idrecv, Sel: GO.Ident{ti.query.filterField}},
			Sel: GO.Ident{"Params"},
		}}

		if ti.query.kind == queryKindUpdate {
			var stmt1 GO.AssignStmt
			stmt1.Token = GO.AssignDefine
			stmt1.Lhs = idparams
			stmt1.Rhs = GO.SliceLit{
				Type:  idifaces,
				Elems: GO.ExprList(g.queryargs),
			}

			var stmt2 GO.AssignStmt
			stmt2.Token = GO.Assign
			stmt2.Lhs = idparams
			stmt2.Rhs = GO.CallExpr{Fun: GO.Ident{"append"}, Args: GO.ArgsList{
				List:     GO.ExprList{idparams, call},
				Ellipsis: true,
			}}
			list = append(list, stmt1, stmt2, GO.NL{})
		} else {
			var stmt GO.AssignStmt
			stmt.Token = GO.AssignDefine
			stmt.Lhs = idparams
			stmt.Rhs = call
			list = append(list, stmt)
		}
		return list
	}
	return GO.NoOp{}
}

func (g *generator) queryexec(ti *targetInfo) (stmt GO.StmtNode) {
	args := GO.ArgsList{List: idquery}
	if len(g.insx) > 0 || len(ti.query.filterField) > 0 || ((ti.query.kind == queryKindInsert || ti.query.kind == queryKindUpdate) && ti.query.dataField.data.isSlice && len(g.queryargs) > 0) {
		args.AddExprs(idparams)
		args.Ellipsis = true
	} else {
		args.AddExprs(g.queryargs...)
		if args.Len() > 3 {
			args.OnePerLine = 2
		}
	}

	// produce c.Exec( ... ) call
	{
		if !ti.query.kind.isSelect() && ti.query.returnList == nil && ti.query.resultField == nil {

			if rafield := ti.query.rowsAffectedField; rafield != nil {
				// call exec & assign res, err
				asn := GO.AssignStmt{Token: GO.AssignDefine}
				asn.Lhs = GO.ExprList{idres, iderr}
				asn.Rhs = GO.CallExpr{Fun: sxexec, Args: args}

				// check err
				iferr := GO.IfStmt{}
				iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
				iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

				// call RowsAffected & assing i64, err
				asn2 := GO.AssignStmt{Token: GO.AssignDefine}
				asn2.Lhs = GO.ExprList{idi64, iderr}
				asn2.Rhs = callresrowsaffected

				// check err
				iferr2 := GO.IfStmt{}
				iferr2.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
				iferr2.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

				//
				asn3 := GO.AssignStmt{Token: GO.Assign}
				asn3.Lhs = GO.SelectorExpr{X: idrecv, Sel: GO.Ident{rafield.name}}
				if rafield.kind == typeKindInt64 {
					asn3.Rhs = idi64
				} else {
					args := GO.ArgsList{List: idi64}
					asn3.Rhs = GO.CallExpr{Fun: GO.Ident{rafield.kind.String()}, Args: args}
				}

				return GO.StmtList{asn, iferr, asn2, iferr2, GO.NL{}, asn3}
			} else {
				asn := GO.AssignStmt{Token: GO.AssignDefine}
				asn.Lhs = GO.ExprList{idblank, iderr}
				asn.Rhs = GO.CallExpr{Fun: sxexec, Args: args}
				return asn
			}
		}
	}

	// produce c.QueryRow( ... ) call
	{
		data := ti.query.dataField.data
		if ti.query.resultField != nil {
			data = ti.query.resultField.data
		}

		if !data.isSlice && !data.isIter {
			asn := GO.AssignStmt{Token: GO.AssignDefine}
			asn.Lhs = idrow
			asn.Rhs = GO.CallExpr{Fun: sxqueryrow, Args: args}
			//return GO.StmtList{asn, GO.NL{}}
			return GO.StmtList{asn}
		}
	}

	// produce c.Query( ... ) call with if-err-check, defer-rows-close, and
	// for-rows-next loop to scan the rows
	{

		asn := GO.AssignStmt{Token: GO.AssignDefine}
		asn.Lhs = GO.ExprList{idrows, iderr}
		asn.Rhs = GO.CallExpr{Fun: sxquery, Args: args}

		iferr := GO.IfStmt{}
		iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
		iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

		defclose := GO.DeferStmt{}
		defclose.Call = GO.CallExpr{Fun: sxrowsclose}

		fornext := g.fornext(ti, g.scantoinput)
		if g.scantoinput {
			asni := GO.AssignStmt{Token: GO.AssignDefine}
			asni.Lhs = GO.Ident{"i"}
			asni.Rhs = GO.IntLit(0)
			return GO.StmtList{asn, iferr, defclose, GO.NL{}, asni, fornext}
		}
		return GO.StmtList{asn, iferr, defclose, GO.NL{}, fornext}
	}
	return stmt
}

func (g *generator) returnerr(ti *targetInfo, errx GO.ExprNode) GO.ReturnStmt {
	if ti.query.errorHandlerField == nil {
		return GO.ReturnStmt{errx}
	}
	if ti.query.errorHandlerField.isInfo {
		lit := GO.StructLit{Type: sxerrorinfo, Compact: true}
		lit.Elems = []GO.FieldElement{
			{"Error", iderr},
			{"Query", idquery},
			{"SpecKind", GO.StringLit(ti.query.kind.String())},
			{"SpecName", GO.StringLit(ti.query.name)},
			{"SpecValue", idrecv},
		}
		litptr := GO.UnaryExpr{Op: GO.UnaryAmp, X: lit}

		sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{ti.query.errorHandlerField.name}}
		fun := GO.SelectorExpr{X: sx, Sel: GO.Ident{"HandleErrorInfo"}}
		call := GO.CallExpr{Fun: fun, Args: GO.ArgsList{List: litptr}}
		return GO.ReturnStmt{call}

		// TODO if errx is not iderr, then errx is probably a CallFunc and
		// should first be executed and it's result passed into HandleErrorInfo..
	}
	sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{ti.query.errorHandlerField.name}}
	fun := GO.SelectorExpr{X: sx, Sel: GO.Ident{"HandleError"}}
	call := GO.CallExpr{Fun: fun, Args: GO.ArgsList{List: errx}}
	return GO.ReturnStmt{call}
}

func (g *generator) fornext(ti *targetInfo, inputscan bool) (stmt GO.ForStmt) {
	stmt.Clause = GO.ForCondition{callrowsnext}
	// scan & assign error
	{
		var args GO.ArgsList
		if len(g.scanargs) > 2 {
			args.OnePerLine = 1
		}
		args.AddExprs(g.scanargs...)
		stmt.Body.List = append(stmt.Body.List, g.scaninits...)

		asn := GO.AssignStmt{Token: GO.AssignDefine}
		asn.Lhs = iderr
		asn.Rhs = GO.CallExpr{Fun: sxrowsscan, Args: args}
		stmt.Body.List = append(stmt.Body.List, asn)
	}

	// check error & newline
	{
		iferr := GO.IfStmt{}
		iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
		iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}
		stmt.Body.List = append(stmt.Body.List, iferr, GO.NL{})
	}

	// append OR iterate
	{
		data := ti.query.dataField.data
		fieldname := ti.query.dataField.name
		if ti.query.resultField != nil {
			data = ti.query.resultField.data
			fieldname = ti.query.resultField.name
		}

		if data.isAfterScanner {
			// call afterscan
			sx := GO.SelectorExpr{X: g.scanroot, Sel: idafterscan}
			afterscan := GO.ExprStmt{GO.CallExpr{Fun: sx}}
			stmt.Body.List = append(stmt.Body.List, afterscan)
		}

		if data.isIter {
			var call GO.CallExpr
			if len(data.iterMethod) > 0 {
				call = GO.CallExpr{Fun: GO.SelectorExpr{
					X:   GO.SelectorExpr{X: idrecv, Sel: GO.Ident{fieldname}},
					Sel: GO.Ident{data.iterMethod}},
					Args: GO.ArgsList{List: GO.Ident{"v"}},
				}
			} else {
				call = GO.CallExpr{Fun: GO.SelectorExpr{
					X:   idrecv,
					Sel: GO.Ident{fieldname}},
					Args: GO.ArgsList{List: GO.Ident{"v"}},
				}
			}

			asn := GO.AssignStmt{Token: GO.AssignDefine}
			asn.Lhs = iderr
			asn.Rhs = call

			iferr := GO.IfStmt{}
			iferr.Init = asn
			iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
			iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}
			stmt.Body.List = append(stmt.Body.List, iferr)
		} else if g.scantoinput {
			asn := GO.AssignStmt{Token: GO.AssignAdd}
			asn.Lhs = GO.Ident{"i"}
			asn.Rhs = GO.IntLit(1)
			stmt.Body.List = append(stmt.Body.List, asn)
		} else {
			appnd := GO.CallExpr{Fun: GO.Ident{"append"}}
			appnd.Args = GO.ArgsList{List: GO.ExprList{
				GO.SelectorExpr{X: idrecv, Sel: GO.Ident{fieldname}},
				GO.Ident{"v"},
			}}

			asn := GO.AssignStmt{Token: GO.Assign}
			asn.Lhs = GO.SelectorExpr{X: idrecv, Sel: GO.Ident{fieldname}}
			asn.Rhs = appnd
			stmt.Body.List = append(stmt.Body.List, asn)
		}
	}
	return stmt
}

func (g *generator) returnstmt(ti *targetInfo) (stmt GO.StmtNode) {
	if ti.query.rowsAffectedField != nil {
		return GO.ReturnStmt{idnil}
	}
	if ti.query.kind.isSelect() || ti.query.returnList != nil {
		dataField := ti.query.dataField

		// does the record type need pre-allocation? and is it imported?
		if dataField.data.typeInfo.isImported && (dataField.data.isSlice || dataField.data.isPointer) && (ti.query.kind != queryKindInsert && ti.query.kind != queryKindUpdate) {
			g.addimport(dataField.data.typeInfo.pkgPath, dataField.data.typeInfo.pkgName, dataField.data.typeInfo.pkgLocal)
		}

		if dataField.data.isSlice || dataField.data.isArray || dataField.data.isIter {
			if ti.query.errorHandlerField != nil && ti.query.errorHandlerField.isInfo {
				asn := GO.AssignStmt{Token: GO.AssignDefine}
				asn.Lhs = iderr
				asn.Rhs = callrowserr

				iferr := GO.IfStmt{}
				iferr.Init = asn
				iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
				iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

				return GO.StmtList{iferr, GO.ReturnStmt{idnil}}
			}
			return g.returnerr(ti, callrowserr)
		} else {
			var args GO.ArgsList
			var list GO.StmtList // result

			if ti.query.kind.isNonFromSelect() {
				fx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{dataField.name}}
				args.AddExprs(GO.UnaryExpr{Op: GO.UnaryAmp, X: fx})
			} else {
				if len(g.scanargs) > 2 {
					args.OnePerLine = 1
				}
				args.AddExprs(g.scanargs...)
				list = append(list, g.scaninits...)
			}

			if !dataField.data.isAfterScanner {
				call := GO.CallExpr{Fun: sxrowscan, Args: args}
				if ti.query.errorHandlerField != nil && ti.query.errorHandlerField.isInfo {
					asn := GO.AssignStmt{Token: GO.AssignDefine}
					asn.Lhs = iderr
					asn.Rhs = call

					iferr := GO.IfStmt{}
					iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
					iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

					list = append(list, asn, iferr, GO.ReturnStmt{idnil})
				} else {
					list = append(list, g.returnerr(ti, call))
				}
			} else {
				// scan & assign error
				asn := GO.AssignStmt{Token: GO.AssignDefine}
				asn.Lhs = iderr
				asn.Rhs = GO.CallExpr{Fun: sxrowscan, Args: args}

				// check error
				iferr := GO.IfStmt{}
				iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
				iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

				// call afterscan
				sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{dataField.name}}
				sx = GO.SelectorExpr{X: sx, Sel: idafterscan}
				afterscan := GO.ExprStmt{GO.CallExpr{Fun: sx}}

				// call afterscan
				ret := GO.ReturnStmt{idnil}

				// done
				list = append(list, asn, iferr, GO.NL{}, afterscan, ret)
			}

			return list
		}
	}

	// result field
	if ti.query.resultField != nil {
		rel := ti.query.resultField
		// does the record type need pre-allocation? and is it imported?
		if rel.data.typeInfo.isImported && (rel.data.isSlice || rel.data.isPointer) {
			g.addimport(rel.data.typeInfo.pkgPath, rel.data.typeInfo.pkgName, rel.data.typeInfo.pkgLocal)
		}

		if rel.data.isSlice || rel.data.isArray || rel.data.isIter {
			if ti.query.errorHandlerField != nil && ti.query.errorHandlerField.isInfo {
				asn := GO.AssignStmt{Token: GO.AssignDefine}
				asn.Lhs = iderr
				asn.Rhs = callrowserr

				iferr := GO.IfStmt{}
				iferr.Init = asn
				iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
				iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

				return GO.StmtList{iferr, GO.ReturnStmt{idnil}}
			}
			return g.returnerr(ti, callrowserr)
		} else {
			var args GO.ArgsList
			if len(g.scanargs) > 2 {
				args.OnePerLine = 1
			}
			args.AddExprs(g.scanargs...)

			var list GO.StmtList // result
			list = append(list, g.scaninits...)

			if !rel.data.isAfterScanner {
				call := GO.CallExpr{Fun: sxrowscan, Args: args}
				if ti.query.errorHandlerField != nil && ti.query.errorHandlerField.isInfo {
					asn := GO.AssignStmt{Token: GO.AssignDefine}
					asn.Lhs = iderr
					asn.Rhs = call

					iferr := GO.IfStmt{}
					iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
					iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

					list = append(list, asn, iferr, GO.ReturnStmt{idnil})
				} else {
					list = append(list, g.returnerr(ti, call))
				}
			} else {
				// scan & assing error
				asn := GO.AssignStmt{Token: GO.AssignDefine}
				asn.Lhs = iderr
				asn.Rhs = GO.CallExpr{Fun: sxrowscan, Args: args}

				// check error
				iferr := GO.IfStmt{}
				iferr.Cond = GO.BinaryExpr{X: iderr, Op: GO.BinaryNeq, Y: idnil}
				iferr.Body = GO.BlockStmt{List: []GO.StmtNode{g.returnerr(ti, iderr)}}

				// call afterscan
				sx := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{rel.name}}
				sx = GO.SelectorExpr{X: sx, Sel: idafterscan}
				afterscan := GO.ExprStmt{GO.CallExpr{Fun: sx}}

				// call afterscan
				ret := GO.ReturnStmt{idnil}

				// done
				list = append(list, asn, iferr, GO.NL{}, afterscan, ret)
			}

			return list
		}
	}

	return g.returnerr(ti, iderr)
}

func (g *generator) rectype(data dataType) GO.TypeNode {
	if data.typeInfo.isImported {
		return GO.QualifiedIdent{data.typeInfo.pkgName, data.typeInfo.name}
	}
	return GO.Ident{data.typeInfo.name}
}

func (g *generator) pathelemtype(node *fieldNode) GO.TypeNode {
	if node.isImported {
		return GO.QualifiedIdent{node.typePkgName, node.typeName}
	}
	return GO.Ident{node.typeName}
}

func (g *generator) addimport(path, name, local string) {
	// check that the package path hasn't yet been added to the imports
	for _, spec := range g.imports.Specs {
		if string(spec.Path) == path {
			return
		}
	}

	// if the local name is the same as the package name set it to empty
	if local == name {
		local = ""
	}

	spec := GO.ImportSpec{Path: GO.StringLit(path), Name: GO.Ident{local}}
	g.imports.Specs = append(g.imports.Specs, spec)
}

func (g *generator) sqlnode(ti *targetInfo) (node GO.Node) {
	switch ti.query.kind {
	case queryKindInsert:
		return g.sqlinsert(ti)
	case queryKindUpdate:
		return g.sqlupdate(ti)
	case queryKindSelect:
		return g.sqlselect(ti)
	case queryKindSelectCount:
		return g.sqlselectcount(ti)
	case queryKindSelectExists, queryKindSelectNotExists:
		return g.sqlselectexists(ti)
	case queryKindDelete:
		return g.sqldelete(ti)
	}
	return node
}

// sqlinsert builds and returns an SQL.InsertStatement.
func (g *generator) sqlinsert(ti *targetInfo) (stmt SQL.InsertStatement) {
	var src SQL.InsertSource
	if ti.query.dataField.data.isSlice {
		src.Values = &SQL.ValuesClause{}
	} else {
		src.Values = &SQL.ValuesClause{g.sqlInputValues}
	}

	stmt.Head.Table = g.sqlrelid(ti.query.dataField.relId)
	stmt.Head.Columns = g.sqlInputColumns
	stmt.Head.Overriding = overridingKindToSQLOverridingClause[ti.query.overridingKind]
	stmt.Head.Source = src
	//stmt.Head.Source.Select = nil

	if ti.query.dataField.data.isSlice && (len(g.outputcolumns) > 0 || ti.query.onConflictBlock != nil) {
		var tail SQL.InsertTail
		tail.OnConflict = g.sqlonconflict(ti)
		tail.Returning = SQL.ReturningClause(g.outputcolumns)
		g.sqltailnode = tail
	} else {
		stmt.Tail.OnConflict = g.sqlonconflict(ti)
		stmt.Tail.Returning = SQL.ReturningClause(g.outputcolumns)
	}
	return stmt
}

func (g *generator) sqlupdate(ti *targetInfo) (stmt SQL.UpdateStatement) {
	stmt.Head.Table = g.sqlrelid(ti.query.dataField.relId)
	stmt.Head.Set.Targets = g.sqlInputColumns
	stmt.Head.Set.Values.Exprs = g.sqlInputValues
	stmt.Head.From = g.sqlfrom(ti.query.joinBlock)

	if ti.query.kind == queryKindUpdate && ti.query.dataField.data.isSlice {
		// SQL.ValuesListClausePartial{}
		// SQL.ValuesListAliasPartial{}
		stmt.Head.From.List = append(stmt.Head.From.List, SQL.ValuesListClausePartial{})

		var alias SQL.ValuesListAliasPartial
		alias.Alias = "x"
		alias.Columns = append(alias.Columns, g.sqlInputColumns...)
		alias.Columns = append(alias.Columns, g.sqlInputColumns2...)

		var tail SQL.UpdateTail
		tail.Where = g.buildSQLWhereClause(ti)

		g.sqltailnode = SQL.NodeList{alias, tail}
		return stmt
	}

	if ti.query.filterField != "" && len(g.outputcolumns) > 0 {
		var tail SQL.UpdateTail
		tail.Returning = SQL.ReturningClause(g.outputcolumns)
		g.sqltailnode = tail
	} else if ti.query.dataField.data.isSlice && (len(g.outputcolumns) > 0 || ti.query.whereBlock != nil) {
		var tail SQL.UpdateTail
		tail.Where = g.buildSQLWhereClause(ti)
		tail.Returning = SQL.ReturningClause(g.outputcolumns)
		g.sqltailnode = tail
	} else {
		stmt.Tail.Where = g.buildSQLWhereClause(ti)
		stmt.Tail.Returning = SQL.ReturningClause(g.outputcolumns)
	}

	return stmt
}

// sqlselect builds and returns an SQL.SelectStatement.
func (g *generator) sqlselect(ti *targetInfo) (selstmt SQL.SelectStatement) {
	selstmt.Columns = g.outputcolumns // columns
	selstmt.Table = g.sqlrelid(ti.query.dataField.relId)
	selstmt.Join = g.sqljoin(ti.query.joinBlock)
	selstmt.Where = g.buildSQLWhereClause(ti)
	selstmt.Order = g.sqlorderby(ti.query)
	selstmt.Limit = g.sqllimit(ti.query)
	selstmt.Offset = g.sqloffset(ti.query)
	return selstmt
}

// sqldelete builds and returns an SQL.DeleteStatement.
func (g *generator) sqldelete(ti *targetInfo) (delstmt SQL.DeleteStatement) {
	delstmt.Table = g.sqlrelid(ti.query.dataField.relId)
	delstmt.Using = g.sqlusing(ti.query.joinBlock)
	delstmt.Where = g.buildSQLWhereClause(ti)
	delstmt.Returning = SQL.ReturningClause(g.outputcolumns) //returning
	return delstmt
}

// sqlselectexists builds and returns an SQL.SelectExistsStatement.
func (g *generator) sqlselectexists(ti *targetInfo) (selstmt SQL.SelectExistsStatement) {
	selstmt.Table = g.sqlrelid(ti.query.dataField.relId)
	selstmt.Join = g.sqljoin(ti.query.joinBlock)
	selstmt.Not = ti.query.kind == queryKindSelectNotExists
	if ti.query.filterField == "" {
		selstmt.Where = g.buildSQLWhereClause(ti)
		selstmt.Order = g.sqlorderby(ti.query)
		selstmt.Limit = g.sqllimit(ti.query)
		selstmt.Offset = g.sqloffset(ti.query)
	} else {
		selstmt.Open = true
		g.fclose = true
	}
	return selstmt
}

// sqlselectcount builds and returns an SQL.SelectCountStatement.
func (g *generator) sqlselectcount(ti *targetInfo) (selstmt SQL.SelectCountStatement) {
	selstmt.Table = g.sqlrelid(ti.query.dataField.relId)
	selstmt.Join = g.sqljoin(ti.query.joinBlock)
	if ti.query.filterField == "" {
		selstmt.Where = g.buildSQLWhereClause(ti)
		selstmt.Order = g.sqlorderby(ti.query)
		selstmt.Offset = g.sqloffset(ti.query)
	}
	return selstmt
}

// buildSQLWhereClause builds and returns ...
func (g *generator) buildSQLWhereClause(ti *targetInfo) (where SQL.WhereClause) {
	if w := ti.query.whereBlock; w != nil {
		sel := GO.SelectorExpr{X: idrecv, Sel: GO.Ident{w.name}}
		where.SearchCondition, _ = g.sqlsearchcond(w.conds, sel, false)
	} else if ti.query.kind == queryKindUpdate && (ti.query.all == false && ti.query.filterField == "") {
		var list SQL.BoolValueExprList
		for i, item := range ti.primaryKeys {
			p := SQL.ComparisonPredicate{}
			p.Cmp = predicateToSQLCmpOp[isEQ]
			p.LPredicand = g.sqlcolref(item.colId)

			if item.sqlExpr == nil {
				item.sqlExpr = g.sqlparam()
			}
			p.RPredicand = item.sqlExpr

			if ti.query.dataField.data.isSlice {
				col := SQL.ColumnIdent{Qual: "x", Name: SQL.Name(item.colId.name)}
				p.RPredicand = SQL.CastExpr{Expr: col, Type: item.column.typ.name}
			}

			if i == 0 {
				list.Initial = p
			} else {
				list.Items = append(list.Items, SQL.AND{Operand: p})
			}
		}
		where.SearchCondition = list
	}
	return where
}

func (g *generator) sqlsearchcond(conds []*searchCondition, sel GO.SelectorExpr, parenthesized bool) (list SQL.BoolValueExprList, count int) {
	for _, item := range conds {
		count += 1

		var x SQL.BoolValueExpr
		switch cond := item.cond.(type) {
		// nested: recurse
		case *searchConditionNested:
			var ncount int

			sel := GO.SelectorExpr{X: sel, Sel: GO.Ident{cond.name}}
			x, ncount = g.sqlsearchcond(cond.conds, sel, true)

			count += ncount - 1

		// 3-arg predicate: build & return
		case *searchConditionBetween:
			p := SQL.BetweenPredicate{}
			p.Predicand = g.sqlcolref(cond.colId)
			if x, ok := cond.x.(colId); ok {
				p.LowEnd = g.sqlcolref(x)
			} else {
				// assume cond.x is *fieldDatum
				p.LowEnd = g.sqlparam()
			}
			if y, ok := cond.y.(colId); ok {
				p.HighEnd = g.sqlcolref(y)
			} else {
				// assume cond.x is *fieldDatum
				p.HighEnd = g.sqlparam()
			}
			x = p

		// 2-arg predicates: prepare first, then build & return
		case *searchConditionField, *searchConditionColumn:
			var (
				lhs     SQL.ValueExpr
				rhs     SQL.ValueExpr
				pred    predicate
				qua     quantifier
				field   string
				coltype string
			)

			// prepare
			switch cond := cond.(type) {
			case *searchConditionField:
				pred = cond.pred
				qua = cond.qua
				lhs = g.sqlcolref(cond.colId)
				rhs = g.sqlparam()
				if len(cond.modFunc) > 0 {
					li := SQL.RoutineInvocation{}
					li.Name = string(cond.modFunc)
					li.Args = []SQL.ValueExpr{lhs}
					lhs = li

					ri := SQL.RoutineInvocation{}
					ri.Name = string(cond.modFunc)
					ri.Args = []SQL.ValueExpr{rhs}
					rhs = ri
				}

				if qua > 0 {
					coltype = g.ti.searchConditionFieldColumns[cond].typ.namefmt
				}

				field = cond.name // needed for isin/notin predicates
			case *searchConditionColumn:
				pred = cond.pred
				qua = cond.qua
				lhs = g.sqlcolref(cond.colId)
				if !cond.colId2.isEmpty() {
					rhs = g.sqlcolref(cond.colId2)
				} else if len(cond.literal) > 0 {
					rhs = SQL.Literal{cond.literal}
				}
			}

			// quantifier?
			if qua > 0 {
				if len(coltype) > 0 {
					cast := SQL.CastExpr{}
					cast.Expr = rhs
					cast.Type = coltype + "[]"
					rhs = cast
				}
				qx := SQL.QuantifiedExpr{}
				qx.Qua = quantifierToSQLQuantifier[qua]
				qx.Expr = rhs
				rhs = qx
			}

			// build & return
			switch pred {
			case isEQ, notEQ, notEQ2, isLT, isGT, isLTE, isGTE:
				p := SQL.ComparisonPredicate{}
				p.Cmp = predicateToSQLCmpOp[pred]
				p.LPredicand = lhs
				p.RPredicand = rhs
				x = p
			case isLike, notLike:
				p := SQL.LikePredicate{}
				p.Not = (pred == notLike)
				p.Predicand = lhs
				p.Pattern = rhs
				x = p
			case isILike, notILike:
				p := SQL.ILikePredicate{}
				p.Not = (pred == notILike)
				p.Predicand = lhs
				p.Pattern = rhs
				x = p
			case isSimilar, notSimilar:
				p := SQL.SimilarPredicate{}
				p.Not = (pred == notSimilar)
				p.Predicand = lhs
				p.Pattern = rhs
				x = p
			case isDistinct, notDistinct:
				p := SQL.DistinctPredicate{}
				p.Not = (pred == notDistinct)
				p.LPredicand = lhs
				p.RPredicand = rhs
				x = p
			case isMatch, isMatchi, notMatch, notMatchi:
				p := SQL.RegexPredicate{}
				p.Op = predicateToSQLRegExOp[pred]
				p.Predicand = lhs
				p.Pattern = rhs
				x = p
			case isIn, notIn:
				sx := GO.SelectorExpr{X: sel, Sel: GO.Ident{field}}
				g.insx = append(g.insx, sx)
				g.nparam -= 1  // ordinal param won't be used directly
				g.asvar = true // queryString should be var not const

				num := strconv.Itoa(len(g.insx))
				arg1 := GO.Ident{"len" + num}
				//arg2 := GO.BinaryExpr{X: GO.Ident{"pos" + num}, Op: GO.BinaryAdd, Y: GO.IntLit(1)}
				arg2 := GO.Ident{"pos" + num}

				call := callinvaluelist
				call.Args = GO.ArgsList{List: GO.ExprList{arg1, arg2}}

				p := SQL.InPredicate{}
				p.Not = (pred == notIn)
				p.Predicand = lhs
				p.ValueList = SQL.HostValue{GO.RawStringInsertExpr{call}}
				x = p
			case isTrue, notTrue, isFalse, notFalse, isUnknown, notUnknown:
				p := SQL.TruthPredicate{}
				p.Not = (pred == notTrue || pred == notFalse || pred == notUnknown)
				p.Truth = predicateToSQLTruth[pred]
				p.Predicand = lhs
				x = p
			case isNull, notNull:
				p := SQL.NullPredicate{}
				p.Not = (pred == notNull)
				p.Predicand = lhs
				x = p
			default:
				// no predicate, assume lhs is by itself a boolean value expression
				if p, ok := lhs.(SQL.BoolValueExpr); ok {
					x = p
				}
			}
		}

		switch item.bool {
		default: // initial
			list.Initial = x
		case boolAnd:
			list.Items = append(list.Items, SQL.AND{Operand: x})
		case boolOr:
			list.Items = append(list.Items, SQL.OR{Operand: x})
		}

	}

	if count > 2 {
		list.ListStyle = true
	}

	list.Parenthesized = parenthesized
	return list, count
}

func (g *generator) sqlonconflict(ti *targetInfo) (clause *SQL.OnConflictClause) {
	if ti.query.onConflictBlock == nil {
		return nil
	}

	clause = new(SQL.OnConflictClause)

	// conflict target
	if len(ti.query.onConflictBlock.column) > 0 {
		target := make(SQL.ConflictColumns, len(ti.query.onConflictBlock.column))
		for i := 0; i < len(target); i++ {
			target[i] = SQL.Name(ti.query.onConflictBlock.column[i].name)
		}
		clause.Target = target
	} else if len(ti.query.onConflictBlock.index) > 0 {
		target := SQL.ConflictIndex{}
		target.Expr = ti.onConflictIndex.indexpr
		target.Pred = ti.onConflictIndex.indpred
		clause.Target = target
	} else if len(ti.query.onConflictBlock.constraint) > 0 {
		clause.Target = SQL.ConflictConstraint(ti.query.onConflictBlock.constraint)
	}

	// conflict action
	if ti.query.onConflictBlock.ignore {
		return clause
	} else if ti.query.onConflictBlock.update != nil {
		ux := SQL.UpdateExcluded{}
		if ti.query.onConflictBlock.update.all {
			for _, item := range ti.input {
				if ti.skipwrite(item) {
					continue
				}
				ux.Columns = append(ux.Columns, SQL.Name(item.colId.name))
			}
		} else {
			for _, cid := range ti.query.onConflictBlock.update.items {
				ux.Columns = append(ux.Columns, SQL.Name(cid.name))
			}
		}

		clause.Action = new(SQL.ConflictAction)
		clause.Action.Update = ux
		clause.Action.Update.Compact = len(ux.Columns) == 1
	}
	return clause
}

func (g *generator) sqlorderby(query *queryStruct) (order SQL.OrderClause) {
	if query.orderByList == nil {
		return order
	}

	for _, item := range query.orderByList.items {
		by := SQL.OrderBy{}
		by.Column = g.sqlcolref(item.colId)
		by.Desc = (item.direction == orderDesc)
		order.List = append(order.List, by)
	}
	return order
}

func (g *generator) sqlfrom(jb *joinBlock) (from SQL.FromClause) {
	if jb == nil {
		return from
	}

	from.List = []SQL.TableExpr{g.sqlrelid(jb.relId)}
	for _, item := range jb.items {
		var join SQL.TableJoin
		join.Type = joinTypeToSQLJoinType[item.joinType]
		join.Rel = g.sqlrelid(item.relId)
		join.Cond = g.sqljoincond(item.conds)
		from.List = append(from.List, join)
	}
	return from
}

func (g *generator) sqlusing(jb *joinBlock) (using SQL.UsingClause) {
	if jb == nil {
		return using
	}

	using.List = []SQL.TableExpr{g.sqlrelid(jb.relId)}
	for _, item := range jb.items {
		var join SQL.TableJoin
		join.Type = joinTypeToSQLJoinType[item.joinType]
		join.Rel = g.sqlrelid(item.relId)
		join.Cond = g.sqljoincond(item.conds)
		using.List = append(using.List, join)
	}
	return using
}

func (g *generator) sqljoin(jb *joinBlock) (jc SQL.JoinClause) {
	if jb == nil {
		return jc
	}

	for _, item := range jb.items {
		var join SQL.TableJoin
		join.Type = joinTypeToSQLJoinType[item.joinType]
		join.Rel = g.sqlrelid(item.relId)
		join.Cond = g.sqljoincond(item.conds)
		jc.List = append(jc.List, join)
	}
	return jc
}

func (g *generator) sqljoincond(items []*searchCondition) (cond SQL.JoinCondition) {
	if len(items) > 0 {
		list, _ := g.sqlsearchcond(items, GO.SelectorExpr{}, false)
		list.ListStyle = false

		cond.SearchCondition = list
	}
	return cond
}

// sqllimit generates and returns an SQL.LimitClause based on the given query's "limit" field.
func (g *generator) sqllimit(query *queryStruct) (limit SQL.LimitClause) {
	if query.limitField != nil {
		if len(query.limitField.name) > 0 {
			limit.Value = g.sqlparam()
		} else if query.limitField.value > 0 {
			limit.Value = SQL.LimitUint(query.limitField.value)
		}
		return limit
	}

	// In case the query doesn't have a "limit" field, but the relation
	// field handles only a single record (i.e. it's not a slice, etc.)
	// then, by default, generate a `LIMIT 1` clause.
	if r := query.dataField.data; !r.isArray && !r.isSlice && !r.isIter {
		limit.Value = SQL.LimitInt(1)
		return limit
	}
	return limit
}

// sqloffset generates and returns an SQL.OffsetClause based on the given query's "offset" field.
func (g *generator) sqloffset(query *queryStruct) (offset SQL.OffsetClause) {
	if query.offsetField != nil {
		if len(query.offsetField.name) > 0 {
			offset.Value = g.sqlparam()
		} else if query.offsetField.value > 0 {
			offset.Value = SQL.OffsetUint(query.offsetField.value)
		}
		return offset
	}
	return offset
}

func (g *generator) sqlrelid(id relId) SQL.Ident {
	return SQL.Ident{
		Name:  SQL.Name(id.name),
		Qual:  id.qual,
		Alias: id.alias,
	}
}

func (g *generator) sqlcolref(id colId) SQL.ColumnReference {
	return SQL.ColumnReference{
		Qual: id.qual,
		Name: SQL.Name(id.name),
	}
}

func (g *generator) sqlparam() SQL.OrdinalParameterSpec {
	g.nparam += 1
	return SQL.OrdinalParameterSpec{g.nparam}
}

// declarevar reports whether the queryString value should be declared as a var or as a const.
func (g *generator) declarevar(ti *targetInfo) bool {
	return g.asvar || len(ti.query.filterField) > 0 ||
		((ti.query.kind == queryKindInsert || ti.query.kind == queryKindUpdate) &&
			ti.query.dataField.data.isSlice)
}

func (g *generator) resolveKeyFunc() {
	if len(g.keytag) > 0 {
		if g.keybase {
			g.keyfunc = g._tagNameBase
		} else {
			g.keyfunc = g._tagNameJoin
		}
	} else {
		if g.keybase {
			g.keyfunc = g._fieldNameBase
		} else {
			g.keyfunc = g._fieldNameJoin
		}
	}
}

func (g *generator) _fieldNameBase(fc *fieldColumnInfo) (key string) {
	return fc.field.name
}

func (g *generator) _fieldNameJoin(fc *fieldColumnInfo) (key string) {
	for _, node := range fc.field.path {
		key += node.name + g.keysep
	}
	key += fc.field.name
	return key
}

func (g *generator) _tagNameBase(fc *fieldColumnInfo) (key string) {
	return fc.field.tag.First(g.keytag)
}

func (g *generator) _tagNameJoin(fc *fieldColumnInfo) (key string) {
	for _, node := range fc.field.path {
		key += node.tag.First(g.keytag) + g.keysep
	}
	key += fc.field.tag.First(g.keytag)
	return key
}

var filterMethodNamesReserved = map[string]struct{}{
	"UnmarshalFQL":  struct{}{},
	"UnmarshalSort": struct{}{},
	"TextSearch":    struct{}{},
	"AND":           struct{}{},
	"OR":            struct{}{},
}

var overridingKindToSQLOverridingClause = map[overridingKind]SQL.OverridingClause{
	overridingSystem: "SYSTEM",
	overridingUser:   "USER",
}

var predicateToSQLCmpOp = map[predicate]SQL.CMPOP{
	isEQ:   SQL.EQUAL,
	notEQ:  SQL.NOT_EQUAL,
	notEQ2: SQL.NOT_EQUAL2,
	isLT:   SQL.LESS_THAN,
	isGT:   SQL.GREATER_THAN,
	isLTE:  SQL.LESS_THAN_EQUAL,
	isGTE:  SQL.GREATER_THAN_EQUAL,
}

var predicateToSQLRegExOp = map[predicate]SQL.REGEXOP{
	isMatch:   SQL.MATCH,
	isMatchi:  SQL.MATCH_CI,
	notMatch:  SQL.NOT_MATCH,
	notMatchi: SQL.NOT_MATCH_CI,
}

var predicateToSQLTruth = map[predicate]SQL.TRUTH{
	isUnknown:  SQL.UNKNOWN,
	notUnknown: SQL.UNKNOWN,
	isTrue:     SQL.TRUE,
	notTrue:    SQL.TRUE,
	isFalse:    SQL.FALSE,
	notFalse:   SQL.FALSE,
}

var quantifierToSQLQuantifier = map[quantifier]SQL.QUANTIFIER{
	quantAny:  SQL.ANY,
	quantSome: SQL.SOME,
	quantAll:  SQL.ALL,
}

var joinTypeToSQLJoinType = map[joinType]SQL.JoinType{
	joinLeft:  SQL.JoinLeft,
	joinRight: SQL.JoinRight,
	joinFull:  SQL.JoinFull,
	joinCross: SQL.JoinCross,
}

var gotyp2coltyp2converter = map[goTypeId]map[string]GO.SelectorExpr{
	goTypeBoolSlice:   {"boolean[]": GO.SelectorExpr{ /*TODO*/ }},
	goTypeStringSlice: {"text[]": GO.SelectorExpr{X: GO.Ident{"gosql"}, Sel: GO.Ident{"StringSliceToTextArray"}}},
	goTypeIntSlice: {
		"integer[]":  GO.SelectorExpr{X: GO.Ident{"gosql"}, Sel: GO.Ident{"IntSliceToIntArray"}},
		"smallint[]": GO.SelectorExpr{X: GO.Ident{"gosql"}, Sel: GO.Ident{"IntSliceToIntArray"}},
		"bigint[]":   GO.SelectorExpr{X: GO.Ident{"gosql"}, Sel: GO.Ident{"IntSliceToIntArray"}},
	},
	goTypeInt8Slice: {
		"integer[]":  GO.SelectorExpr{ /*TODO*/ },
		"smallint[]": GO.SelectorExpr{ /*TODO*/ },
		"bigint[]":   GO.SelectorExpr{ /*TODO*/ },
	},
	goTypeInt16Slice: {
		"integer[]":  GO.SelectorExpr{ /*TODO*/ },
		"smallint[]": GO.SelectorExpr{ /*TODO*/ },
		"bigint[]":   GO.SelectorExpr{ /*TODO*/ },
	},
	goTypeInt32Slice: {
		"integer[]":  GO.SelectorExpr{ /*TODO*/ },
		"smallint[]": GO.SelectorExpr{ /*TODO*/ },
		"bigint[]":   GO.SelectorExpr{ /*TODO*/ },
	},
	goTypeInt64Slice: {
		"integer[]":  GO.SelectorExpr{ /*TODO*/ },
		"smallint[]": GO.SelectorExpr{ /*TODO*/ },
		"bigint[]":   GO.SelectorExpr{ /*TODO*/ },
	},
}
